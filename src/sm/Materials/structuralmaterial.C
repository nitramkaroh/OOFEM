/*
 *
 *                 #####    #####   ######  ######  ###   ###
 *               ##   ##  ##   ##  ##      ##      ## ### ##
 *              ##   ##  ##   ##  ####    ####    ##  #  ##
 *             ##   ##  ##   ##  ##      ##      ##     ##
 *            ##   ##  ##   ##  ##      ##      ##     ##
 *            #####    #####   ##      ######  ##     ##
 *
 *
 *             OOFEM : Object Oriented Finite Element Code
 *
 *               Copyright (C) 1993 - 2013   Borek Patzak
 *
 *
 *
 *       Czech Technical University, Faculty of Civil Engineering,
 *   Department of Structural Mechanics, 166 29 Prague, Czech Republic
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include "../sm/Materials/structuralmaterial.h"
#include "domain.h"
#include "verbose.h"
#include "../sm/Materials/structuralms.h"
#include "../sm/Elements/structuralelement.h"
#include "../sm/Elements/nlstructuralelement.h"
#include "gausspoint.h"
#include "floatmatrix.h"
#include "floatarray.h"
#include "mathfem.h"
#include "engngm.h"
#include "fieldmanager.h"
#include "dynamicinputrecord.h"

namespace oofem {
    
std::vector< std::vector<int> > StructuralMaterial :: vIindex = {
    { 1, 6, 5 },
    { 9, 2, 4 },
    { 8, 7, 3 }  
};

std::vector< std::vector<int> > StructuralMaterial :: svIndex = {
    { 1, 6, 5 },
    { 6, 2, 4 },
    { 5, 4, 3 }
};


std::vector< std::vector<int> > StructuralMaterial :: huhu1 = {
    { 1, 3, 0 },
    { 3, 2, 0 },
    { 0, 0, 0 }
};
  
std::vector< std::vector<int> > StructuralMaterial :: huhu2 = {
    { 1, 3, 0 },
    { 4, 2, 0 },
    { 0, 0, 0 }
};


StructuralMaterial :: StructuralMaterial(int n, Domain * d) : Material(n, d) { }  


int
StructuralMaterial :: hasMaterialModeCapability(MaterialMode mode)
//
// returns whether receiver supports given mode
//
{
    return mode == _3dMat || mode == _PlaneStress || mode == _PlaneStrain  || mode == _1dMat ||
           mode == _PlateLayer || mode == _2dBeamLayer || mode == _Fiber;
}


void
StructuralMaterial :: giveRealStressVector(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    ///@todo Move this to StructuralCrossSection ?
    MaterialMode mode = gp->giveMaterialMode();
    if ( mode == _3dMat ) {
        this->giveRealStressVector_3d(answer, gp, reducedStrain, tStep);
    } else if ( mode == _3dDegeneratedShell ) {
        this->giveRealStressVector_3d(answer, gp, reducedStrain, tStep);
    } else if ( mode == _PlaneStrain ) {
        this->giveRealStressVector_PlaneStrain(answer, gp, reducedStrain, tStep);
    } else if ( mode == _PlaneStress ) {
        this->giveRealStressVector_PlaneStress(answer, gp, reducedStrain, tStep);
    } else if ( mode == _1dMat ) {
        this->giveRealStressVector_1d(answer, gp, reducedStrain, tStep);
    } else if ( mode == _2dBeamLayer ) {
        this->giveRealStressVector_2dBeamLayer(answer, gp, reducedStrain, tStep);
    } else if ( mode == _PlateLayer ) {
        this->giveRealStressVector_PlateLayer(answer, gp, reducedStrain, tStep);
    } else if ( mode == _Fiber ) {
        this->giveRealStressVector_Fiber(answer, gp, reducedStrain, tStep);
    } else if ( mode == _2dLattice ) {
        this->giveRealStressVector_Lattice2d(answer, gp, reducedStrain, tStep);
    } else if ( mode == _3dLattice ) {
        this->giveRealStressVector_Lattice3d(answer, gp, reducedStrain, tStep);
    } else if ( mode == _2dPlateSubSoil ) {
        this->giveRealStressVector_2dPlateSubSoil(answer, gp, reducedStrain, tStep);
    } else if ( mode == _3dBeamSubSoil ) {
        this->giveRealStressVector_3dBeamSubSoil(answer, gp, reducedStrain, tStep);
    }
}


void
StructuralMaterial :: giveRealStressVector_3d(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    OOFEM_ERROR("3d mode not supported");
}


void
StructuralMaterial :: giveRealStressVector_Warping(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    OOFEM_ERROR("Warping mode not supported");
}


void
StructuralMaterial :: giveRealStressVector_PlaneStrain(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    FloatArray vE, vS;
    StructuralMaterial :: giveFullSymVectorForm(vE, reducedStrain, _PlaneStrain);
    this->giveRealStressVector_3d(vS, gp, vE, tStep);
    StructuralMaterial :: giveReducedSymVectorForm(answer, vS, _PlaneStrain);
}


void
StructuralMaterial :: giveRealStressVector_StressControl(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, const IntArray &strainControl, TimeStep *tStep)
{
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );

    IntArray stressControl;
    FloatArray vE, increment_vE, vS, reducedvS;
    FloatMatrix tangent, reducedTangent;
    // Iterate to find full vE.
    // Compute the negated the array of control since we need stressControl as well;

    stressControl.resize( 6 - strainControl.giveSize() );
    for ( int i = 1, j = 1; i <= 6; i++ ) {
        if ( !strainControl.contains(i) ) {
            stressControl.at(j++) = i;
        }
    }

    // Initial guess;
    vE = status->giveStrainVector();
    for ( int i = 1; i <= strainControl.giveSize(); ++i ) {
        vE.at( strainControl.at(i) ) = reducedStrain.at(i);
    }

    // Iterate to find full vE.
    for ( int k = 0; k < 100; k++ ) { // Allow for a generous 100 iterations.
        this->giveRealStressVector_3d(vS, gp, vE, tStep);
        // For debugging the iterations:
        //vE.printYourself("vE");
        //vS.printYourself("vS");
        reducedvS.beSubArrayOf(vS, stressControl);
        // Pick out the (response) stresses for the controlled strains
        answer.beSubArrayOf(vS, strainControl);
	if ( reducedvS.computeNorm() <= 1e-8 * answer.computeNorm() && k >= 1 ) { // Absolute tolerance right now (with at least one iteration)
            ///@todo We need a relative tolerance here!
            /// A relative tolerance like this could work, but if a really small increment is performed it won't work
            /// (it will be limited by machine precision)
        //if ( reducedvS.computeNorm() <= 1e-6 * answer.computeNorm() ) {
            return;
        }

        this->give3dMaterialStiffnessMatrix(tangent, TangentStiffness, gp, tStep);
        reducedTangent.beSubMatrixOf(tangent, stressControl, stressControl);
        reducedTangent.solveForRhs(reducedvS, increment_vE);
        increment_vE.negated();
        vE.assemble(increment_vE, stressControl);
    }

    OOFEM_WARNING("Iteration did not converge");
    answer.clear();
}


void
StructuralMaterial :: giveRealStressVector_ShellStressControl(FloatArray &answer, GaussPoint *gp, const FloatArray &strain, const IntArray &strainControl, TimeStep *tStep)
// calculates stress vector (6 components) with assumption of sigma_z = 0
// used by MITC4Shell
{
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );

    IntArray stressControl;
    FloatArray vE, increment_vE, vS, reducedvS;
    FloatMatrix tangent, reducedTangent;
    // Iterate to find full vE.
    // Compute the negated the array of control since we need stressControl as well;

    stressControl.resize( 6 - strainControl.giveSize() );
    for ( int i = 1, j = 1; i <= 6; i++ ) {
        if ( !strainControl.contains(i) ) {
            stressControl.at(j++) = i;
        }
    }

    // Initial guess;
    vE = status->giveStrainVector();
    vE = strain;
    // step 0: vE = {., ., 0, ., ., .}
    // step n: vE = {., ., sum(ve(n)), ., ., .}


    // Iterate to find full vE.
    for ( int k = 0; k < 100; k++ ) { // Allow for a generous 100 iterations.
        this->giveRealStressVector_3d(answer, gp, vE, tStep);
        // step 0: answer = full stress vector
        // step n: answer = {., ., ->0, ., ., .}
        reducedvS.beSubArrayOf(answer, stressControl);
        if ( reducedvS.computeNorm() < 1e-6 ) {
            return;
        }

        this->give3dMaterialStiffnessMatrix(tangent, TangentStiffness, gp, tStep);
        reducedTangent.beSubMatrixOf(tangent, stressControl, stressControl);
        reducedTangent.solveForRhs(reducedvS, increment_vE);
        increment_vE.negated();
        vE.assemble(increment_vE, stressControl);
    }

    OOFEM_WARNING("Iteration did not converge");
    answer.clear();
}




void
StructuralMaterial :: giveRealStressVector_PlaneStress(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    IntArray strainControl;
    StructuralMaterial :: giveVoigtSymVectorMask(strainControl, _PlaneStress);
    this->giveRealStressVector_StressControl(answer, gp, reducedStrain, strainControl, tStep);
}


void
StructuralMaterial :: giveRealStressVector_1d(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    IntArray strainControl;
    StructuralMaterial :: giveVoigtSymVectorMask(strainControl, _1dMat);
    this->giveRealStressVector_StressControl(answer, gp, reducedStrain, strainControl, tStep);
}


void
StructuralMaterial :: giveRealStressVector_2dBeamLayer(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    IntArray strainControl;
    StructuralMaterial :: giveVoigtSymVectorMask(strainControl, _2dBeamLayer);
    this->giveRealStressVector_StressControl(answer, gp, reducedStrain, strainControl, tStep);
}


void
StructuralMaterial :: giveRealStressVector_PlateLayer(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    IntArray strainControl;
    StructuralMaterial :: giveVoigtSymVectorMask(strainControl, _PlateLayer);
    this->giveRealStressVector_StressControl(answer, gp, reducedStrain, strainControl, tStep);
}


void
StructuralMaterial :: giveRealStressVector_Fiber(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    IntArray strainControl;
    StructuralMaterial :: giveVoigtSymVectorMask(strainControl, _Fiber);
    this->giveRealStressVector_StressControl(answer, gp, reducedStrain, strainControl, tStep);
}


void
StructuralMaterial :: giveRealStressVector_Lattice2d(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    OOFEM_ERROR("2dLattice mode not supported");
}

void
StructuralMaterial :: giveRealStressVector_Lattice3d(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    OOFEM_ERROR("3dLattice mode not supported");
}


void
StructuralMaterial :: giveRealStressVector_2dPlateSubSoil(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    OOFEM_ERROR("2dPlateSubSoil mode not supported");
}

void
StructuralMaterial :: giveRealStressVector_3dBeamSubSoil(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    OOFEM_ERROR("3dBeamSubSoil mode not supported");
}


void
StructuralMaterial :: giveRealStressVector_AxisymMembrane1d(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedStrain, TimeStep *tStep)
{
    OOFEM_ERROR("AxisymMembrane1d mode not supported");
}
  

void
StructuralMaterial :: giveFirstPKStressVector_3d(FloatArray &answer, GaussPoint *gp, const FloatArray &vF, TimeStep *tStep)
{
    // Default implementation used if this method is not overloaded by the particular material model.
    // 1) Compute Green-Lagrange strain and call standard method for small strains.
    // 2) Treat stress as second Piola-Kirchhoff stress and convert to first Piola-Kirchhoff stress.
    // 3) Set state variables F, P

    FloatArray vE, vS;
    FloatMatrix F, E;
    F.beMatrixForm(vF);
    E.beTProductOf(F, F);
    E.at(1, 1) -= 1.0;
    E.at(2, 2) -= 1.0;
    E.at(3, 3) -= 1.0;
    E.times(0.5);
    vE.beSymVectorFormOfStrain(E);      // 6

    ///@todo Have this function:
    this->giveRealStressVector_3d(vS, gp, vE, tStep);
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );

    // Compute first PK stress from second PK stress
    FloatMatrix P, S;
    S.beMatrixForm(vS);
    P.beProductOf(F, S);
    answer.beVectorForm(P);

    status->letTempPVectorBe(answer);
    status->letTempFVectorBe(vF);
}


void
StructuralMaterial :: giveFirstPKStressVector_PlaneStrain(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedvF, TimeStep *tStep)
{
    FloatArray vF, vP;
    StructuralMaterial :: giveFullVectorFormF(vF, reducedvF, _PlaneStrain);
    this->giveFirstPKStressVector_3d(vP, gp, vF, tStep);
    StructuralMaterial :: giveReducedVectorForm(answer, vP, _PlaneStrain);
}


void
StructuralMaterial :: giveFirstPKStressVector_PlaneStress(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedvF, TimeStep *tStep)
{
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );

    IntArray F_control, P_control; // Determines which components are controlled by F and P resp.
    FloatArray vF, increment_vF, vP, vP_control;
    FloatMatrix tangent, tangent_Pcontrol;
    // Iterate to find full vF.
    StructuralMaterial :: giveVoigtVectorMask(F_control, _PlaneStress);
    // Compute the negated the array of control since we need P_control as well;
    P_control.resize( 9 - F_control.giveSize() );
    for ( int i = 1, j = 1; i <= 9; i++ ) {
        if ( !F_control.contains(i) ) {
            P_control.at(j++) = i;
        }
    }

    // Initial guess;
    vF = status->giveFVector();
    for ( int i = 1; i <= F_control.giveSize(); ++i ) {
        vF.at( F_control.at(i) ) = reducedvF.at(i);
    }

    // Iterate to find full vF.
    for ( int k = 0; k < 100; k++ ) { // Allow for a generous 100 iterations.
        this->giveFirstPKStressVector_3d(vP, gp, vF, tStep);
        vP_control.beSubArrayOf(vP, P_control);
        if ( vP_control.computeNorm() < 1e-6 ) { ///@todo We need a tolerance here!
            StructuralMaterial :: giveReducedVectorForm(answer, vP, _PlaneStress);
            return;
        }

        this->give3dMaterialStiffnessMatrix_dPdF(tangent, TangentStiffness, gp, tStep);
        tangent_Pcontrol.beSubMatrixOf(tangent, P_control, P_control);
        tangent_Pcontrol.solveForRhs(vP_control, increment_vF);
	increment_vF.negated();
        vF.assemble(increment_vF, P_control);
    }

    OOFEM_WARNING("Iteration did not converge");
    answer.clear();
}


void
StructuralMaterial :: giveFirstPKStressVector_Membrane2d(FloatArray &answer, GaussPoint *gp, const FloatArray &vF, TimeStep *tStep)
{
  this->giveFirstPKStressVector_PlaneStress(answer, gp, vF, tStep);

  
  /*
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );
    IntArray F_control, P_control; // Determines which components are controlled by F and P resp.
    FloatArray increment_vF, vP, vP_control;
    FloatMatrix tangent, tangent_Pcontrol;
    // Iterate to find full vF.
    StructuralMaterial :: giveVoigtVectorMask(F_control, _Membrane2d);

    double n1,n2,n3;
    n1 = vF.at(5);
    n2 = vF.at(4);
    n3 = vF.at(3);
    

    
    FloatArray iiF(9);
    iiF.at(3) = vF.at(3);
    iiF.at(4) = vF.at(4);
    iiF.at(5) = vF.at(5);
    

    // Compute the negated the array of control since we need P_control as well;
    P_control.resize( 9 - F_control.giveSize() );
    for ( int i = 1, j = 1; i <= 9; i++ ) {
        if ( !F_control.contains(i) ) {
            P_control.at(j++) = i;
        }
    }

    // Initial guess;
    //   vF = status->giveFVector();
    //for ( int i = 1; i <= F_control.giveSize(); ++i ) {
    //  vF.at( F_control.at(i) ) = reducedvF.at(i);
    //	}

    // Iterate to find full vF.
    for ( int k = 0; k < 100; k++ ) { // Allow for a generous 100 iterations.
      //
      FloatArray vE, vS, vPt;
      FloatMatrix F, E, S, P;
      F.beMatrixForm(vF);
      E.beTProductOf(F, F);
      E.at(1, 1) -= 1.0;
      E.at(2, 2) -= 1.0;
      E.at(3, 3) -= 1.0;
      E.times(0.5);
      vE.beSymVectorFormOfStrain(E);      // 6
      //@todo Have this function:
      //      this->giveRealStressVector_3d(vS, gp, vE, tStep);
      // S.beMatrixForm(vS);
      //P.beProductOf(F, S);
      //vPt.beVectorForm(P);
      //
      this->giveFirstPKStressVector_3d(vP, gp, vF, tStep);
        vP_control.beSubArrayOf(vP, P_control);
	double norm = vP.computeNorm();
        if ( vP_control.computeNorm() <= 1e-10*norm ) { ///@todo We need a tolerance here!
            StructuralMaterial :: giveReducedVectorForm(answer, vP, _Membrane2d);
            return;
        }

	


        this->give3dMaterialStiffnessMatrix_dPdF(tangent, TangentStiffness, gp, tStep);
        tangent_Pcontrol.beSubMatrixOf(tangent, P_control, P_control);

	double kk = tangent_Pcontrol.at(1,1)*n3 + tangent_Pcontrol.at(1,2) * n2 + tangent_Pcontrol.at(1,3) * n1;
	double l = vP_control.at(1)/kk;

	
        tangent_Pcontrol.solveForRhs(vP_control, increment_vF);
	//
	FloatArray ivE, ivF(9);
	FloatMatrix iF, iE, iE2, iE3;
	ivF.assemble(increment_vF, P_control);
	iF.beMatrixForm(ivF);
	iE.beTProductOf(iF, iF);
	iE2.beTProductOf(F, iF);
	iE3.beTProductOf(iF, F);
	iE.add(iE2);
	iE.add(iE3);
	iE.times(0.5);
	ivE.beSymVectorFormOfStrain(iE);
	//
	double dF = vP.at(3)/tangent.at(3,3);
	iiF.times(dF);
	iF.beMatrixForm(iiF);
	iE.beTProductOf(iF, iF);
	iE2.beTProductOf(F, iF);
	iE3.beTProductOf(iF, F);
	iE.add(iE2);
	iE.add(iE3);
	iE.times(0.5);
	ivE.beSymVectorFormOfStrain(iE);
	
	increment_vF.negated();
	vF.assemble(increment_vF, P_control);
    }

    OOFEM_WARNING("Iteration did not converge");
    answer.clear();
    */
}


  

void
StructuralMaterial :: giveFirstPKStressVector_1d(FloatArray &answer, GaussPoint *gp, const FloatArray &vF, TimeStep *tStep)
{
  StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );

    FloatArray vE(1), vS(1);
    vE.at(1) = (vF.at(1)*vF.at(1)*-1.)/2.;
    ///@todo Have this function:
    this->giveRealStressVector_1d(vS, gp, vE, tStep);
    // Compute first PK stress from second PK stress
    answer.resize(1);
    answer.at(1) = vF.at(1)*vS.at(1);

    status->letTempPVectorBe(answer);
    status->letTempFVectorBe(vF);

 
   
}


void
StructuralMaterial :: giveCauchyStressVector_3d(FloatArray &answer, GaussPoint *gp, const FloatArray &incvF, TimeStep *tStep)
{
  double J;
  FloatArray vFn, vP, vF;
  FloatMatrix Fn, f, F, C, P;
  StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus* >( this->giveStatus(gp) );
  vFn = status->giveFVector();
  Fn.beMatrixForm(vFn);
  f.beMatrixForm(incvF);
  F.beProductOf(f,Fn);
  
  J = F.giveDeterminant();
  if(J <= 0) {
    OOFEM_ERROR("Negative volume");
  }

  vF.beVectorForm(F);      
  this->giveFirstPKStressVector_3d(vP, gp, vF, tStep);

  P.beMatrixForm(vP);
  C.beProductTOf(P,F);
  C.times(1./J);

  answer.beVectorForm(C);
  
}




void
StructuralMaterial :: giveCauchyStressVector_PlaneStrain(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedvF, TimeStep *tStep)
{
    FloatArray vF, vC;
    StructuralMaterial :: giveFullVectorFormF(vF, reducedvF, _PlaneStrain);
    this->giveCauchyStressVector_3d(vC, gp, vF, tStep);
    StructuralMaterial :: giveReducedSymVectorForm(answer, vC, _PlaneStrain);
}


void
StructuralMaterial :: giveCauchyStressVector_PlaneStress(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedvF, TimeStep *tStep)
{
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );

    IntArray F_control, C_control, V_control; // Determines which components are controlled by F and Cauchy resp.
    FloatArray vF, increment_vF, vC, vC_control;
    FloatMatrix tangent, tangent_Ccontrol;
    // Iterate to find full vF.
    StructuralMaterial :: giveVoigtVectorMask(F_control, _PlaneStress);
    StructuralMaterial :: giveVoigtSymVectorMask(V_control, _PlaneStress);
    // Compute the negated the array of control since we need P_control as well;
    C_control.resize( 6 - V_control.giveSize() );
    for ( int i = 1, j = 1; i <= 9; i++ ) {
        if ( !F_control.contains(i) ) {
	  if(j <= 6) {
	    C_control.at(j++) = i;
	  }
        }
    }

    // Initial guess;
    vF = status->giveFVector();
    for ( int i = 1; i <= F_control.giveSize(); ++i ) {
        vF.at( F_control.at(i) ) = reducedvF.at(i);
    }

    // Iterate to find full vF.
    for ( int k = 0; k < 100; k++ ) { // Allow for a generous 100 iterations.
        this->giveCauchyStressVector_3d(vC, gp, vF, tStep);
        vC_control.beSubArrayOf(vC, V_control);
        if ( vC_control.computeNorm() < 1e-6 ) { ///@todo We need a tolerance here!
            StructuralMaterial :: giveReducedVectorForm(answer, vC, _PlaneStress);
            return;
        }

        this->giveSpatial3dMaterialStiffnessMatrix(tangent, TangentStiffness, gp, tStep);
        tangent_Ccontrol.beSubMatrixOf(tangent, C_control, C_control);
        tangent_Ccontrol.solveForRhs(vC_control, increment_vF);
        vF.assemble(increment_vF, C_control);
    }

    OOFEM_WARNING("Iteration did not converge");
    answer.clear();
}

void
StructuralMaterial :: giveCauchyStressVector_1d(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedvF, TimeStep *tStep)
{
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );

    IntArray F_control, C_control, V_control; // Determines which components are controlled by F and Cauchy resp.
    FloatArray vF, increment_vF, vC, vC_control;
    FloatMatrix tangent, tangent_Ccontrol;
    // Iterate to find full vF.
    StructuralMaterial :: giveVoigtVectorMask(F_control, _PlaneStress);
    StructuralMaterial :: giveVoigtSymVectorMask(V_control, _PlaneStress);
    // Compute the negated the array of control since we need P_control as well;
    C_control.resize( 6 - V_control.giveSize() );
    for ( int i = 1, j = 1; i <= 9; i++ ) {
        if ( !F_control.contains(i) ) {
	  if(j <= 6) {
	    C_control.at(j++) = i;
	  }
        }
    }

    // Initial guess;
    vF = status->giveFVector();
    for ( int i = 1; i <= F_control.giveSize(); ++i ) {
        vF.at( F_control.at(i) ) = reducedvF.at(i);
    }

    // Iterate to find full vF.
    for ( int k = 0; k < 100; k++ ) { // Allow for a generous 100 iterations.
        this->giveCauchyStressVector_3d(vC, gp, vF, tStep);
        vC_control.beSubArrayOf(vC, V_control);
        if ( vC_control.computeNorm() < 1e-6 ) { ///@todo We need a tolerance here!
            StructuralMaterial :: giveReducedVectorForm(answer, vC, _1dMat);
            return;
        }

        this->giveSpatial3dMaterialStiffnessMatrix(tangent, TangentStiffness, gp, tStep);
        tangent_Ccontrol.beSubMatrixOf(tangent, C_control, C_control);
        tangent_Ccontrol.solveForRhs(vC_control, increment_vF);
        vF.assemble(increment_vF, C_control);
    }

    OOFEM_WARNING("Iteration did not converge");
    answer.clear();
}




void
StructuralMaterial :: convert_dSdE_2_dPdF(FloatMatrix &answer, const FloatMatrix &C, const FloatArray &S, const FloatArray &F, MaterialMode matMode)
{
    // Converts the reduced dSdE-stiffness to reduced dPdF-sitiffness for different MaterialModes
    // Performs the following operation dPdF = I_ik * S_jl + F_im F_kn C_mjnl,
    // See for example: G.A. Holzapfel, Nonlinear Solid Mechanics: A Continuum Approach for
    // Engineering, 2000, ISBN-10: 0471823198.
    FloatMatrix answer1;
    if ( matMode == _3dMat ) {
        //Save terms associated with H = [du/dx, dv/dy, dw/dz, dv/dz, du/dz, du/dy, dw/dy, dw/dx, dv/dx]

        answer.resize(9, 9);
        answer(0, 0) = F(0) * C(0, 0) * F(0) + F(0) * C(0, 5) * F(5) + F(0) * C(0, 4) * F(4) + F(5) * C(5, 0) * F(0) + F(5) * C(5, 5) * F(5) + F(5) * C(5, 4) * F(4) + F(4) * C(4, 0) * F(0) + F(4) * C(4, 5) * F(5) + F(4) * C(4, 4) * F(4) + S(0);
        answer(0, 1) = F(0) * C(0, 5) * F(8) + F(0) * C(0, 1) * F(1) + F(0) * C(0, 3) * F(3) + F(5) * C(5, 5) * F(8) + F(5) * C(5, 1) * F(1) + F(5) * C(5, 3) * F(3) + F(4) * C(4, 5) * F(8) + F(4) * C(4, 1) * F(1) + F(4) * C(4, 3) * F(3) + 0.0;
        answer(0, 2) = F(0) * C(0, 4) * F(7) + F(0) * C(0, 3) * F(6) + F(0) * C(0, 2) * F(2) + F(5) * C(5, 4) * F(7) + F(5) * C(5, 3) * F(6) + F(5) * C(5, 2) * F(2) + F(4) * C(4, 4) * F(7) + F(4) * C(4, 3) * F(6) + F(4) * C(4, 2) * F(2) + 0.0;
        answer(0, 3) = F(0) * C(0, 4) * F(8) + F(0) * C(0, 3) * F(1) + F(0) * C(0, 2) * F(3) + F(5) * C(5, 4) * F(8) + F(5) * C(5, 3) * F(1) + F(5) * C(5, 2) * F(3) + F(4) * C(4, 4) * F(8) + F(4) * C(4, 3) * F(1) + F(4) * C(4, 2) * F(3) + 0.0;
        answer(0, 4) = F(0) * C(0, 4) * F(0) + F(0) * C(0, 3) * F(5) + F(0) * C(0, 2) * F(4) + F(5) * C(5, 4) * F(0) + F(5) * C(5, 3) * F(5) + F(5) * C(5, 2) * F(4) + F(4) * C(4, 4) * F(0) + F(4) * C(4, 3) * F(5) + F(4) * C(4, 2) * F(4) + S(4);
        answer(0, 5) = F(0) * C(0, 5) * F(0) + F(0) * C(0, 1) * F(5) + F(0) * C(0, 3) * F(4) + F(5) * C(5, 5) * F(0) + F(5) * C(5, 1) * F(5) + F(5) * C(5, 3) * F(4) + F(4) * C(4, 5) * F(0) + F(4) * C(4, 1) * F(5) + F(4) * C(4, 3) * F(4) + S(5);
        answer(0, 6) = F(0) * C(0, 5) * F(7) + F(0) * C(0, 1) * F(6) + F(0) * C(0, 3) * F(2) + F(5) * C(5, 5) * F(7) + F(5) * C(5, 1) * F(6) + F(5) * C(5, 3) * F(2) + F(4) * C(4, 5) * F(7) + F(4) * C(4, 1) * F(6) + F(4) * C(4, 3) * F(2) + 0.0;
        answer(0, 7) = F(0) * C(0, 0) * F(7) + F(0) * C(0, 5) * F(6) + F(0) * C(0, 4) * F(2) + F(5) * C(5, 0) * F(7) + F(5) * C(5, 5) * F(6) + F(5) * C(5, 4) * F(2) + F(4) * C(4, 0) * F(7) + F(4) * C(4, 5) * F(6) + F(4) * C(4, 4) * F(2) + 0.0;
        answer(0, 8) = F(0) * C(0, 0) * F(8) + F(0) * C(0, 5) * F(1) + F(0) * C(0, 4) * F(3) + F(5) * C(5, 0) * F(8) + F(5) * C(5, 5) * F(1) + F(5) * C(5, 4) * F(3) + F(4) * C(4, 0) * F(8) + F(4) * C(4, 5) * F(1) + F(4) * C(4, 4) * F(3) + 0.0;
        answer(1, 0) = F(8) * C(5, 0) * F(0) + F(8) * C(5, 5) * F(5) + F(8) * C(5, 4) * F(4) + F(1) * C(1, 0) * F(0) + F(1) * C(1, 5) * F(5) + F(1) * C(1, 4) * F(4) + F(3) * C(3, 0) * F(0) + F(3) * C(3, 5) * F(5) + F(3) * C(3, 4) * F(4) + 0.0;
        answer(1, 1) = F(8) * C(5, 5) * F(8) + F(8) * C(5, 1) * F(1) + F(8) * C(5, 3) * F(3) + F(1) * C(1, 5) * F(8) + F(1) * C(1, 1) * F(1) + F(1) * C(1, 3) * F(3) + F(3) * C(3, 5) * F(8) + F(3) * C(3, 1) * F(1) + F(3) * C(3, 3) * F(3) + S(1);
        answer(1, 2) = F(8) * C(5, 4) * F(7) + F(8) * C(5, 3) * F(6) + F(8) * C(5, 2) * F(2) + F(1) * C(1, 4) * F(7) + F(1) * C(1, 3) * F(6) + F(1) * C(1, 2) * F(2) + F(3) * C(3, 4) * F(7) + F(3) * C(3, 3) * F(6) + F(3) * C(3, 2) * F(2) + 0.0;
        answer(1, 3) = F(8) * C(5, 4) * F(8) + F(8) * C(5, 3) * F(1) + F(8) * C(5, 2) * F(3) + F(1) * C(1, 4) * F(8) + F(1) * C(1, 3) * F(1) + F(1) * C(1, 2) * F(3) + F(3) * C(3, 4) * F(8) + F(3) * C(3, 3) * F(1) + F(3) * C(3, 2) * F(3) + S(3);
        answer(1, 4) = F(8) * C(5, 4) * F(0) + F(8) * C(5, 3) * F(5) + F(8) * C(5, 2) * F(4) + F(1) * C(1, 4) * F(0) + F(1) * C(1, 3) * F(5) + F(1) * C(1, 2) * F(4) + F(3) * C(3, 4) * F(0) + F(3) * C(3, 3) * F(5) + F(3) * C(3, 2) * F(4) + 0.0;
        answer(1, 5) = F(8) * C(5, 5) * F(0) + F(8) * C(5, 1) * F(5) + F(8) * C(5, 3) * F(4) + F(1) * C(1, 5) * F(0) + F(1) * C(1, 1) * F(5) + F(1) * C(1, 3) * F(4) + F(3) * C(3, 5) * F(0) + F(3) * C(3, 1) * F(5) + F(3) * C(3, 3) * F(4) + 0.0;
        answer(1, 6) = F(8) * C(5, 5) * F(7) + F(8) * C(5, 1) * F(6) + F(8) * C(5, 3) * F(2) + F(1) * C(1, 5) * F(7) + F(1) * C(1, 1) * F(6) + F(1) * C(1, 3) * F(2) + F(3) * C(3, 5) * F(7) + F(3) * C(3, 1) * F(6) + F(3) * C(3, 3) * F(2) + 0.0;
        answer(1, 7) = F(8) * C(5, 0) * F(7) + F(8) * C(5, 5) * F(6) + F(8) * C(5, 4) * F(2) + F(1) * C(1, 0) * F(7) + F(1) * C(1, 5) * F(6) + F(1) * C(1, 4) * F(2) + F(3) * C(3, 0) * F(7) + F(3) * C(3, 5) * F(6) + F(3) * C(3, 4) * F(2) + 0.0;
        answer(1, 8) = F(8) * C(5, 0) * F(8) + F(8) * C(5, 5) * F(1) + F(8) * C(5, 4) * F(3) + F(1) * C(1, 0) * F(8) + F(1) * C(1, 5) * F(1) + F(1) * C(1, 4) * F(3) + F(3) * C(3, 0) * F(8) + F(3) * C(3, 5) * F(1) + F(3) * C(3, 4) * F(3) + S(5);
        answer(2, 0) = F(7) * C(4, 0) * F(0) + F(7) * C(4, 5) * F(5) + F(7) * C(4, 4) * F(4) + F(6) * C(3, 0) * F(0) + F(6) * C(3, 5) * F(5) + F(6) * C(3, 4) * F(4) + F(2) * C(2, 0) * F(0) + F(2) * C(2, 5) * F(5) + F(2) * C(2, 4) * F(4) + 0.0;
        answer(2, 1) = F(7) * C(4, 5) * F(8) + F(7) * C(4, 1) * F(1) + F(7) * C(4, 3) * F(3) + F(6) * C(3, 5) * F(8) + F(6) * C(3, 1) * F(1) + F(6) * C(3, 3) * F(3) + F(2) * C(2, 5) * F(8) + F(2) * C(2, 1) * F(1) + F(2) * C(2, 3) * F(3) + 0.0;
        answer(2, 2) = F(7) * C(4, 4) * F(7) + F(7) * C(4, 3) * F(6) + F(7) * C(4, 2) * F(2) + F(6) * C(3, 4) * F(7) + F(6) * C(3, 3) * F(6) + F(6) * C(3, 2) * F(2) + F(2) * C(2, 4) * F(7) + F(2) * C(2, 3) * F(6) + F(2) * C(2, 2) * F(2) + S(2);
        answer(2, 3) = F(7) * C(4, 4) * F(8) + F(7) * C(4, 3) * F(1) + F(7) * C(4, 2) * F(3) + F(6) * C(3, 4) * F(8) + F(6) * C(3, 3) * F(1) + F(6) * C(3, 2) * F(3) + F(2) * C(2, 4) * F(8) + F(2) * C(2, 3) * F(1) + F(2) * C(2, 2) * F(3) + 0.0;
        answer(2, 4) = F(7) * C(4, 4) * F(0) + F(7) * C(4, 3) * F(5) + F(7) * C(4, 2) * F(4) + F(6) * C(3, 4) * F(0) + F(6) * C(3, 3) * F(5) + F(6) * C(3, 2) * F(4) + F(2) * C(2, 4) * F(0) + F(2) * C(2, 3) * F(5) + F(2) * C(2, 2) * F(4) + 0.0;
        answer(2, 5) = F(7) * C(4, 5) * F(0) + F(7) * C(4, 1) * F(5) + F(7) * C(4, 3) * F(4) + F(6) * C(3, 5) * F(0) + F(6) * C(3, 1) * F(5) + F(6) * C(3, 3) * F(4) + F(2) * C(2, 5) * F(0) + F(2) * C(2, 1) * F(5) + F(2) * C(2, 3) * F(4) + 0.0;
        answer(2, 6) = F(7) * C(4, 5) * F(7) + F(7) * C(4, 1) * F(6) + F(7) * C(4, 3) * F(2) + F(6) * C(3, 5) * F(7) + F(6) * C(3, 1) * F(6) + F(6) * C(3, 3) * F(2) + F(2) * C(2, 5) * F(7) + F(2) * C(2, 1) * F(6) + F(2) * C(2, 3) * F(2) + S(3);
        answer(2, 7) = F(7) * C(4, 0) * F(7) + F(7) * C(4, 5) * F(6) + F(7) * C(4, 4) * F(2) + F(6) * C(3, 0) * F(7) + F(6) * C(3, 5) * F(6) + F(6) * C(3, 4) * F(2) + F(2) * C(2, 0) * F(7) + F(2) * C(2, 5) * F(6) + F(2) * C(2, 4) * F(2) + S(4);
        answer(2, 8) = F(7) * C(4, 0) * F(8) + F(7) * C(4, 5) * F(1) + F(7) * C(4, 4) * F(3) + F(6) * C(3, 0) * F(8) + F(6) * C(3, 5) * F(1) + F(6) * C(3, 4) * F(3) + F(2) * C(2, 0) * F(8) + F(2) * C(2, 5) * F(1) + F(2) * C(2, 4) * F(3) + 0.0;
        answer(3, 0) = F(8) * C(4, 0) * F(0) + F(8) * C(4, 5) * F(5) + F(8) * C(4, 4) * F(4) + F(1) * C(3, 0) * F(0) + F(1) * C(3, 5) * F(5) + F(1) * C(3, 4) * F(4) + F(3) * C(2, 0) * F(0) + F(3) * C(2, 5) * F(5) + F(3) * C(2, 4) * F(4) + 0.0;
        answer(3, 1) = F(8) * C(4, 5) * F(8) + F(8) * C(4, 1) * F(1) + F(8) * C(4, 3) * F(3) + F(1) * C(3, 5) * F(8) + F(1) * C(3, 1) * F(1) + F(1) * C(3, 3) * F(3) + F(3) * C(2, 5) * F(8) + F(3) * C(2, 1) * F(1) + F(3) * C(2, 3) * F(3) + S(3);
        answer(3, 2) = F(8) * C(4, 4) * F(7) + F(8) * C(4, 3) * F(6) + F(8) * C(4, 2) * F(2) + F(1) * C(3, 4) * F(7) + F(1) * C(3, 3) * F(6) + F(1) * C(3, 2) * F(2) + F(3) * C(2, 4) * F(7) + F(3) * C(2, 3) * F(6) + F(3) * C(2, 2) * F(2) + 0.0;
        answer(3, 3) = F(8) * C(4, 4) * F(8) + F(8) * C(4, 3) * F(1) + F(8) * C(4, 2) * F(3) + F(1) * C(3, 4) * F(8) + F(1) * C(3, 3) * F(1) + F(1) * C(3, 2) * F(3) + F(3) * C(2, 4) * F(8) + F(3) * C(2, 3) * F(1) + F(3) * C(2, 2) * F(3) + S(2);
        answer(3, 4) = F(8) * C(4, 4) * F(0) + F(8) * C(4, 3) * F(5) + F(8) * C(4, 2) * F(4) + F(1) * C(3, 4) * F(0) + F(1) * C(3, 3) * F(5) + F(1) * C(3, 2) * F(4) + F(3) * C(2, 4) * F(0) + F(3) * C(2, 3) * F(5) + F(3) * C(2, 2) * F(4) + 0.0;
        answer(3, 5) = F(8) * C(4, 5) * F(0) + F(8) * C(4, 1) * F(5) + F(8) * C(4, 3) * F(4) + F(1) * C(3, 5) * F(0) + F(1) * C(3, 1) * F(5) + F(1) * C(3, 3) * F(4) + F(3) * C(2, 5) * F(0) + F(3) * C(2, 1) * F(5) + F(3) * C(2, 3) * F(4) + 0.0;
        answer(3, 6) = F(8) * C(4, 5) * F(7) + F(8) * C(4, 1) * F(6) + F(8) * C(4, 3) * F(2) + F(1) * C(3, 5) * F(7) + F(1) * C(3, 1) * F(6) + F(1) * C(3, 3) * F(2) + F(3) * C(2, 5) * F(7) + F(3) * C(2, 1) * F(6) + F(3) * C(2, 3) * F(2) + 0.0;
        answer(3, 7) = F(8) * C(4, 0) * F(7) + F(8) * C(4, 5) * F(6) + F(8) * C(4, 4) * F(2) + F(1) * C(3, 0) * F(7) + F(1) * C(3, 5) * F(6) + F(1) * C(3, 4) * F(2) + F(3) * C(2, 0) * F(7) + F(3) * C(2, 5) * F(6) + F(3) * C(2, 4) * F(2) + 0.0;
        answer(3, 8) = F(8) * C(4, 0) * F(8) + F(8) * C(4, 5) * F(1) + F(8) * C(4, 4) * F(3) + F(1) * C(3, 0) * F(8) + F(1) * C(3, 5) * F(1) + F(1) * C(3, 4) * F(3) + F(3) * C(2, 0) * F(8) + F(3) * C(2, 5) * F(1) + F(3) * C(2, 4) * F(3) + S(4);
        answer(4, 0) = F(0) * C(4, 0) * F(0) + F(0) * C(4, 5) * F(5) + F(0) * C(4, 4) * F(4) + F(5) * C(3, 0) * F(0) + F(5) * C(3, 5) * F(5) + F(5) * C(3, 4) * F(4) + F(4) * C(2, 0) * F(0) + F(4) * C(2, 5) * F(5) + F(4) * C(2, 4) * F(4) + S(4);
        answer(4, 1) = F(0) * C(4, 5) * F(8) + F(0) * C(4, 1) * F(1) + F(0) * C(4, 3) * F(3) + F(5) * C(3, 5) * F(8) + F(5) * C(3, 1) * F(1) + F(5) * C(3, 3) * F(3) + F(4) * C(2, 5) * F(8) + F(4) * C(2, 1) * F(1) + F(4) * C(2, 3) * F(3) + 0.0;
        answer(4, 2) = F(0) * C(4, 4) * F(7) + F(0) * C(4, 3) * F(6) + F(0) * C(4, 2) * F(2) + F(5) * C(3, 4) * F(7) + F(5) * C(3, 3) * F(6) + F(5) * C(3, 2) * F(2) + F(4) * C(2, 4) * F(7) + F(4) * C(2, 3) * F(6) + F(4) * C(2, 2) * F(2) + 0.0;
        answer(4, 3) = F(0) * C(4, 4) * F(8) + F(0) * C(4, 3) * F(1) + F(0) * C(4, 2) * F(3) + F(5) * C(3, 4) * F(8) + F(5) * C(3, 3) * F(1) + F(5) * C(3, 2) * F(3) + F(4) * C(2, 4) * F(8) + F(4) * C(2, 3) * F(1) + F(4) * C(2, 2) * F(3) + 0.0;
        answer(4, 4) = F(0) * C(4, 4) * F(0) + F(0) * C(4, 3) * F(5) + F(0) * C(4, 2) * F(4) + F(5) * C(3, 4) * F(0) + F(5) * C(3, 3) * F(5) + F(5) * C(3, 2) * F(4) + F(4) * C(2, 4) * F(0) + F(4) * C(2, 3) * F(5) + F(4) * C(2, 2) * F(4) + S(2);
        answer(4, 5) = F(0) * C(4, 5) * F(0) + F(0) * C(4, 1) * F(5) + F(0) * C(4, 3) * F(4) + F(5) * C(3, 5) * F(0) + F(5) * C(3, 1) * F(5) + F(5) * C(3, 3) * F(4) + F(4) * C(2, 5) * F(0) + F(4) * C(2, 1) * F(5) + F(4) * C(2, 3) * F(4) + S(3);
        answer(4, 6) = F(0) * C(4, 5) * F(7) + F(0) * C(4, 1) * F(6) + F(0) * C(4, 3) * F(2) + F(5) * C(3, 5) * F(7) + F(5) * C(3, 1) * F(6) + F(5) * C(3, 3) * F(2) + F(4) * C(2, 5) * F(7) + F(4) * C(2, 1) * F(6) + F(4) * C(2, 3) * F(2) + 0.0;
        answer(4, 7) = F(0) * C(4, 0) * F(7) + F(0) * C(4, 5) * F(6) + F(0) * C(4, 4) * F(2) + F(5) * C(3, 0) * F(7) + F(5) * C(3, 5) * F(6) + F(5) * C(3, 4) * F(2) + F(4) * C(2, 0) * F(7) + F(4) * C(2, 5) * F(6) + F(4) * C(2, 4) * F(2) + 0.0;
        answer(4, 8) = F(0) * C(4, 0) * F(8) + F(0) * C(4, 5) * F(1) + F(0) * C(4, 4) * F(3) + F(5) * C(3, 0) * F(8) + F(5) * C(3, 5) * F(1) + F(5) * C(3, 4) * F(3) + F(4) * C(2, 0) * F(8) + F(4) * C(2, 5) * F(1) + F(4) * C(2, 4) * F(3) + 0.0;
        answer(5, 0) = F(0) * C(5, 0) * F(0) + F(0) * C(5, 5) * F(5) + F(0) * C(5, 4) * F(4) + F(5) * C(1, 0) * F(0) + F(5) * C(1, 5) * F(5) + F(5) * C(1, 4) * F(4) + F(4) * C(3, 0) * F(0) + F(4) * C(3, 5) * F(5) + F(4) * C(3, 4) * F(4) + S(5);
        answer(5, 1) = F(0) * C(5, 5) * F(8) + F(0) * C(5, 1) * F(1) + F(0) * C(5, 3) * F(3) + F(5) * C(1, 5) * F(8) + F(5) * C(1, 1) * F(1) + F(5) * C(1, 3) * F(3) + F(4) * C(3, 5) * F(8) + F(4) * C(3, 1) * F(1) + F(4) * C(3, 3) * F(3) + 0.0;
        answer(5, 2) = F(0) * C(5, 4) * F(7) + F(0) * C(5, 3) * F(6) + F(0) * C(5, 2) * F(2) + F(5) * C(1, 4) * F(7) + F(5) * C(1, 3) * F(6) + F(5) * C(1, 2) * F(2) + F(4) * C(3, 4) * F(7) + F(4) * C(3, 3) * F(6) + F(4) * C(3, 2) * F(2) + 0.0;
        answer(5, 3) = F(0) * C(5, 4) * F(8) + F(0) * C(5, 3) * F(1) + F(0) * C(5, 2) * F(3) + F(5) * C(1, 4) * F(8) + F(5) * C(1, 3) * F(1) + F(5) * C(1, 2) * F(3) + F(4) * C(3, 4) * F(8) + F(4) * C(3, 3) * F(1) + F(4) * C(3, 2) * F(3) + 0.0;
        answer(5, 4) = F(0) * C(5, 4) * F(0) + F(0) * C(5, 3) * F(5) + F(0) * C(5, 2) * F(4) + F(5) * C(1, 4) * F(0) + F(5) * C(1, 3) * F(5) + F(5) * C(1, 2) * F(4) + F(4) * C(3, 4) * F(0) + F(4) * C(3, 3) * F(5) + F(4) * C(3, 2) * F(4) + S(3);
        answer(5, 5) = F(0) * C(5, 5) * F(0) + F(0) * C(5, 1) * F(5) + F(0) * C(5, 3) * F(4) + F(5) * C(1, 5) * F(0) + F(5) * C(1, 1) * F(5) + F(5) * C(1, 3) * F(4) + F(4) * C(3, 5) * F(0) + F(4) * C(3, 1) * F(5) + F(4) * C(3, 3) * F(4) + S(1);
        answer(5, 6) = F(0) * C(5, 5) * F(7) + F(0) * C(5, 1) * F(6) + F(0) * C(5, 3) * F(2) + F(5) * C(1, 5) * F(7) + F(5) * C(1, 1) * F(6) + F(5) * C(1, 3) * F(2) + F(4) * C(3, 5) * F(7) + F(4) * C(3, 1) * F(6) + F(4) * C(3, 3) * F(2) + 0.0;
        answer(5, 7) = F(0) * C(5, 0) * F(7) + F(0) * C(5, 5) * F(6) + F(0) * C(5, 4) * F(2) + F(5) * C(1, 0) * F(7) + F(5) * C(1, 5) * F(6) + F(5) * C(1, 4) * F(2) + F(4) * C(3, 0) * F(7) + F(4) * C(3, 5) * F(6) + F(4) * C(3, 4) * F(2) + 0.0;
        answer(5, 8) = F(0) * C(5, 0) * F(8) + F(0) * C(5, 5) * F(1) + F(0) * C(5, 4) * F(3) + F(5) * C(1, 0) * F(8) + F(5) * C(1, 5) * F(1) + F(5) * C(1, 4) * F(3) + F(4) * C(3, 0) * F(8) + F(4) * C(3, 5) * F(1) + F(4) * C(3, 4) * F(3) + 0.0;
        answer(6, 0) = F(7) * C(5, 0) * F(0) + F(7) * C(5, 5) * F(5) + F(7) * C(5, 4) * F(4) + F(6) * C(1, 0) * F(0) + F(6) * C(1, 5) * F(5) + F(6) * C(1, 4) * F(4) + F(2) * C(3, 0) * F(0) + F(2) * C(3, 5) * F(5) + F(2) * C(3, 4) * F(4) + 0.0;
        answer(6, 1) = F(7) * C(5, 5) * F(8) + F(7) * C(5, 1) * F(1) + F(7) * C(5, 3) * F(3) + F(6) * C(1, 5) * F(8) + F(6) * C(1, 1) * F(1) + F(6) * C(1, 3) * F(3) + F(2) * C(3, 5) * F(8) + F(2) * C(3, 1) * F(1) + F(2) * C(3, 3) * F(3) + 0.0;
        answer(6, 2) = F(7) * C(5, 4) * F(7) + F(7) * C(5, 3) * F(6) + F(7) * C(5, 2) * F(2) + F(6) * C(1, 4) * F(7) + F(6) * C(1, 3) * F(6) + F(6) * C(1, 2) * F(2) + F(2) * C(3, 4) * F(7) + F(2) * C(3, 3) * F(6) + F(2) * C(3, 2) * F(2) + S(3);
        answer(6, 3) = F(7) * C(5, 4) * F(8) + F(7) * C(5, 3) * F(1) + F(7) * C(5, 2) * F(3) + F(6) * C(1, 4) * F(8) + F(6) * C(1, 3) * F(1) + F(6) * C(1, 2) * F(3) + F(2) * C(3, 4) * F(8) + F(2) * C(3, 3) * F(1) + F(2) * C(3, 2) * F(3) + 0.0;
        answer(6, 4) = F(7) * C(5, 4) * F(0) + F(7) * C(5, 3) * F(5) + F(7) * C(5, 2) * F(4) + F(6) * C(1, 4) * F(0) + F(6) * C(1, 3) * F(5) + F(6) * C(1, 2) * F(4) + F(2) * C(3, 4) * F(0) + F(2) * C(3, 3) * F(5) + F(2) * C(3, 2) * F(4) + 0.0;
        answer(6, 5) = F(7) * C(5, 5) * F(0) + F(7) * C(5, 1) * F(5) + F(7) * C(5, 3) * F(4) + F(6) * C(1, 5) * F(0) + F(6) * C(1, 1) * F(5) + F(6) * C(1, 3) * F(4) + F(2) * C(3, 5) * F(0) + F(2) * C(3, 1) * F(5) + F(2) * C(3, 3) * F(4) + 0.0;
        answer(6, 6) = F(7) * C(5, 5) * F(7) + F(7) * C(5, 1) * F(6) + F(7) * C(5, 3) * F(2) + F(6) * C(1, 5) * F(7) + F(6) * C(1, 1) * F(6) + F(6) * C(1, 3) * F(2) + F(2) * C(3, 5) * F(7) + F(2) * C(3, 1) * F(6) + F(2) * C(3, 3) * F(2) + S(1);
        answer(6, 7) = F(7) * C(5, 0) * F(7) + F(7) * C(5, 5) * F(6) + F(7) * C(5, 4) * F(2) + F(6) * C(1, 0) * F(7) + F(6) * C(1, 5) * F(6) + F(6) * C(1, 4) * F(2) + F(2) * C(3, 0) * F(7) + F(2) * C(3, 5) * F(6) + F(2) * C(3, 4) * F(2) + S(5);
        answer(6, 8) = F(7) * C(5, 0) * F(8) + F(7) * C(5, 5) * F(1) + F(7) * C(5, 4) * F(3) + F(6) * C(1, 0) * F(8) + F(6) * C(1, 5) * F(1) + F(6) * C(1, 4) * F(3) + F(2) * C(3, 0) * F(8) + F(2) * C(3, 5) * F(1) + F(2) * C(3, 4) * F(3) + 0.0;
        answer(7, 0) = F(7) * C(0, 0) * F(0) + F(7) * C(0, 5) * F(5) + F(7) * C(0, 4) * F(4) + F(6) * C(5, 0) * F(0) + F(6) * C(5, 5) * F(5) + F(6) * C(5, 4) * F(4) + F(2) * C(4, 0) * F(0) + F(2) * C(4, 5) * F(5) + F(2) * C(4, 4) * F(4) + 0.0;
        answer(7, 1) = F(7) * C(0, 5) * F(8) + F(7) * C(0, 1) * F(1) + F(7) * C(0, 3) * F(3) + F(6) * C(5, 5) * F(8) + F(6) * C(5, 1) * F(1) + F(6) * C(5, 3) * F(3) + F(2) * C(4, 5) * F(8) + F(2) * C(4, 1) * F(1) + F(2) * C(4, 3) * F(3) + 0.0;
        answer(7, 2) = F(7) * C(0, 4) * F(7) + F(7) * C(0, 3) * F(6) + F(7) * C(0, 2) * F(2) + F(6) * C(5, 4) * F(7) + F(6) * C(5, 3) * F(6) + F(6) * C(5, 2) * F(2) + F(2) * C(4, 4) * F(7) + F(2) * C(4, 3) * F(6) + F(2) * C(4, 2) * F(2) + S(4);
        answer(7, 3) = F(7) * C(0, 4) * F(8) + F(7) * C(0, 3) * F(1) + F(7) * C(0, 2) * F(3) + F(6) * C(5, 4) * F(8) + F(6) * C(5, 3) * F(1) + F(6) * C(5, 2) * F(3) + F(2) * C(4, 4) * F(8) + F(2) * C(4, 3) * F(1) + F(2) * C(4, 2) * F(3) + 0.0;
        answer(7, 4) = F(7) * C(0, 4) * F(0) + F(7) * C(0, 3) * F(5) + F(7) * C(0, 2) * F(4) + F(6) * C(5, 4) * F(0) + F(6) * C(5, 3) * F(5) + F(6) * C(5, 2) * F(4) + F(2) * C(4, 4) * F(0) + F(2) * C(4, 3) * F(5) + F(2) * C(4, 2) * F(4) + 0.0;
        answer(7, 5) = F(7) * C(0, 5) * F(0) + F(7) * C(0, 1) * F(5) + F(7) * C(0, 3) * F(4) + F(6) * C(5, 5) * F(0) + F(6) * C(5, 1) * F(5) + F(6) * C(5, 3) * F(4) + F(2) * C(4, 5) * F(0) + F(2) * C(4, 1) * F(5) + F(2) * C(4, 3) * F(4) + 0.0;
        answer(7, 6) = F(7) * C(0, 5) * F(7) + F(7) * C(0, 1) * F(6) + F(7) * C(0, 3) * F(2) + F(6) * C(5, 5) * F(7) + F(6) * C(5, 1) * F(6) + F(6) * C(5, 3) * F(2) + F(2) * C(4, 5) * F(7) + F(2) * C(4, 1) * F(6) + F(2) * C(4, 3) * F(2) + S(5);
        answer(7, 7) = F(7) * C(0, 0) * F(7) + F(7) * C(0, 5) * F(6) + F(7) * C(0, 4) * F(2) + F(6) * C(5, 0) * F(7) + F(6) * C(5, 5) * F(6) + F(6) * C(5, 4) * F(2) + F(2) * C(4, 0) * F(7) + F(2) * C(4, 5) * F(6) + F(2) * C(4, 4) * F(2) + S(0);
        answer(7, 8) = F(7) * C(0, 0) * F(8) + F(7) * C(0, 5) * F(1) + F(7) * C(0, 4) * F(3) + F(6) * C(5, 0) * F(8) + F(6) * C(5, 5) * F(1) + F(6) * C(5, 4) * F(3) + F(2) * C(4, 0) * F(8) + F(2) * C(4, 5) * F(1) + F(2) * C(4, 4) * F(3) + 0.0;
        answer(8, 0) = F(8) * C(0, 0) * F(0) + F(8) * C(0, 5) * F(5) + F(8) * C(0, 4) * F(4) + F(1) * C(5, 0) * F(0) + F(1) * C(5, 5) * F(5) + F(1) * C(5, 4) * F(4) + F(3) * C(4, 0) * F(0) + F(3) * C(4, 5) * F(5) + F(3) * C(4, 4) * F(4) + 0.0;
        answer(8, 1) = F(8) * C(0, 5) * F(8) + F(8) * C(0, 1) * F(1) + F(8) * C(0, 3) * F(3) + F(1) * C(5, 5) * F(8) + F(1) * C(5, 1) * F(1) + F(1) * C(5, 3) * F(3) + F(3) * C(4, 5) * F(8) + F(3) * C(4, 1) * F(1) + F(3) * C(4, 3) * F(3) + S(5);
        answer(8, 2) = F(8) * C(0, 4) * F(7) + F(8) * C(0, 3) * F(6) + F(8) * C(0, 2) * F(2) + F(1) * C(5, 4) * F(7) + F(1) * C(5, 3) * F(6) + F(1) * C(5, 2) * F(2) + F(3) * C(4, 4) * F(7) + F(3) * C(4, 3) * F(6) + F(3) * C(4, 2) * F(2) + 0.0;
        answer(8, 3) = F(8) * C(0, 4) * F(8) + F(8) * C(0, 3) * F(1) + F(8) * C(0, 2) * F(3) + F(1) * C(5, 4) * F(8) + F(1) * C(5, 3) * F(1) + F(1) * C(5, 2) * F(3) + F(3) * C(4, 4) * F(8) + F(3) * C(4, 3) * F(1) + F(3) * C(4, 2) * F(3) + S(4);
        answer(8, 4) = F(8) * C(0, 4) * F(0) + F(8) * C(0, 3) * F(5) + F(8) * C(0, 2) * F(4) + F(1) * C(5, 4) * F(0) + F(1) * C(5, 3) * F(5) + F(1) * C(5, 2) * F(4) + F(3) * C(4, 4) * F(0) + F(3) * C(4, 3) * F(5) + F(3) * C(4, 2) * F(4) + 0.0;
        answer(8, 5) = F(8) * C(0, 5) * F(0) + F(8) * C(0, 1) * F(5) + F(8) * C(0, 3) * F(4) + F(1) * C(5, 5) * F(0) + F(1) * C(5, 1) * F(5) + F(1) * C(5, 3) * F(4) + F(3) * C(4, 5) * F(0) + F(3) * C(4, 1) * F(5) + F(3) * C(4, 3) * F(4) + 0.0;
        answer(8, 6) = F(8) * C(0, 5) * F(7) + F(8) * C(0, 1) * F(6) + F(8) * C(0, 3) * F(2) + F(1) * C(5, 5) * F(7) + F(1) * C(5, 1) * F(6) + F(1) * C(5, 3) * F(2) + F(3) * C(4, 5) * F(7) + F(3) * C(4, 1) * F(6) + F(3) * C(4, 3) * F(2) + 0.0;
        answer(8, 7) = F(8) * C(0, 0) * F(7) + F(8) * C(0, 5) * F(6) + F(8) * C(0, 4) * F(2) + F(1) * C(5, 0) * F(7) + F(1) * C(5, 5) * F(6) + F(1) * C(5, 4) * F(2) + F(3) * C(4, 0) * F(7) + F(3) * C(4, 5) * F(6) + F(3) * C(4, 4) * F(2) + 0.0;
        answer(8, 8) = F(8) * C(0, 0) * F(8) + F(8) * C(0, 5) * F(1) + F(8) * C(0, 4) * F(3) + F(1) * C(5, 0) * F(8) + F(1) * C(5, 5) * F(1) + F(1) * C(5, 4) * F(3) + F(3) * C(4, 0) * F(8) + F(3) * C(4, 5) * F(1) + F(3) * C(4, 4) * F(3) + S(0);

         ///@todo Experimental - added 110814 by JB
        // Conversion expressed in index form. Seems a tiny bit slower than that above but easier to debug.
        FloatMatrix I(3, 3);
        I.beUnitMatrix();

        //I_ik * S_jl + F_im F_kn C_mjnl
        answer1.resize(9, 9);
	answer1.zero();
        for ( int i = 1; i <= 3; i++ ) {
            for ( int j = 1; j <= 3; j++ ) {
                for ( int k = 1; k <= 3; k++ ) {
                    for ( int l = 1; l <= 3; l++ ) {
		      answer1.at( giveVI(i, j), giveVI(k, l) ) += I.at(i, k) * S.at( giveSymVI(j, l) );
                        for ( int m = 1; m <= 3; m++ ) {
                            for ( int n = 1; n <= 3; n++ ) {
                                answer1.at( giveVI(i, j), giveVI(k, l) ) += F.at( giveVI(i, m) ) * F.at( giveVI(k, n) ) * C.at( giveSymVI(m, j), giveSymVI(n, l) );
                            }
                        }
                    }
                }
            }
        }


    } else if ( matMode == _PlaneStress ) {
        // Save terms associated with H = [du/dx dv/dy du/dy dv/dx]
        answer.resize(4, 4);
        answer(0, 0) = F(0) * C(0, 0) * F(0) + F(0) * C(0, 2) * F(2) + F(2) * C(2, 0) * F(0) + F(2) * C(2, 2) * F(2) + S(0);
        answer(0, 1) = F(0) * C(0, 2) * F(3) + F(0) * C(0, 1) * F(1) + F(2) * C(2, 2) * F(3) + F(2) * C(2, 1) * F(1) + 0.0;
        answer(0, 2) = F(0) * C(0, 2) * F(0) + F(0) * C(0, 1) * F(2) + F(2) * C(2, 2) * F(0) + F(2) * C(2, 1) * F(2) + S(2);
        answer(0, 3) = F(0) * C(0, 0) * F(3) + F(0) * C(0, 2) * F(1) + F(2) * C(2, 0) * F(3) + F(2) * C(2, 2) * F(1) + 0.0;
        answer(1, 0) = F(3) * C(2, 0) * F(0) + F(3) * C(2, 2) * F(2) + F(1) * C(1, 0) * F(0) + F(1) * C(1, 2) * F(2) + 0.0;
        answer(1, 1) = F(3) * C(2, 2) * F(3) + F(3) * C(2, 1) * F(1) + F(1) * C(1, 2) * F(3) + F(1) * C(1, 1) * F(1) + S(1);
        answer(1, 2) = F(3) * C(2, 2) * F(0) + F(3) * C(2, 1) * F(2) + F(1) * C(1, 2) * F(0) + F(1) * C(1, 1) * F(2) + 0.0;
        answer(1, 3) = F(3) * C(2, 0) * F(3) + F(3) * C(2, 2) * F(1) + F(1) * C(1, 0) * F(3) + F(1) * C(1, 2) * F(1) + S(2);
        answer(2, 0) = F(0) * C(2, 0) * F(0) + F(0) * C(2, 2) * F(2) + F(2) * C(1, 0) * F(0) + F(2) * C(1, 2) * F(2) + S(2);
        answer(2, 1) = F(0) * C(2, 2) * F(3) + F(0) * C(2, 1) * F(1) + F(2) * C(1, 2) * F(3) + F(2) * C(1, 1) * F(1) + 0.0;
        answer(2, 2) = F(0) * C(2, 2) * F(0) + F(0) * C(2, 1) * F(2) + F(2) * C(1, 2) * F(0) + F(2) * C(1, 1) * F(2) + S(1);
        answer(2, 3) = F(0) * C(2, 0) * F(3) + F(0) * C(2, 2) * F(1) + F(2) * C(1, 0) * F(3) + F(2) * C(1, 2) * F(1) + 0.0;
        answer(3, 0) = F(3) * C(0, 0) * F(0) + F(3) * C(0, 2) * F(2) + F(1) * C(2, 0) * F(0) + F(1) * C(2, 2) * F(2) + 0.0;
        answer(3, 1) = F(3) * C(0, 2) * F(3) + F(3) * C(0, 1) * F(1) + F(1) * C(2, 2) * F(3) + F(1) * C(2, 1) * F(1) + S(2);
        answer(3, 2) = F(3) * C(0, 2) * F(0) + F(3) * C(0, 1) * F(2) + F(1) * C(2, 2) * F(0) + F(1) * C(2, 1) * F(2) + 0.0;
        answer(3, 3) = F(3) * C(0, 0) * F(3) + F(3) * C(0, 2) * F(1) + F(1) * C(2, 0) * F(3) + F(1) * C(2, 2) * F(1) + S(0);


	FloatMatrix answer1(4,4);
	FloatMatrix I(3, 3);
        I.beUnitMatrix();
	for ( int i = 1; i <= 2; i++ ) {
	  for ( int j = 1; j <= 2; j++ ) {
	    for ( int k = 1; k <= 2; k++ ) {
	      for ( int l = 1; l <= 2; l++ ) {
		answer1.at( giveVIPS(i, j), giveVIPS(k, l) ) += I.at(i, k) * S.at( giveSymVIPS(j, l) );
		for ( int m = 1; m <= 2; m++ ) {
		  for ( int n = 1; n <= 2; n++ ) {
		    answer1.at( giveVIPS(i, j), giveVIPS(k, l) ) += F.at( giveVIPS(i, m) ) * F.at( giveVIPS(k, n) ) * C.at( giveSymVIPS(m, j), giveSymVIPS(n, l) );
		  }
		}
	      }
	    }
	  }
	}

    } else if ( matMode == _PlaneStrain ) {
        //Save terms associated with H = [du/dx, dv/dy, dw/dz, du/dy, dv/dx] //@todo not fully checked

        answer.resize(5, 5);
        answer(0, 0) = F(0) * C(0, 0) * F(0) + F(0) * C(0, 3) * F(3) + F(3) * C(3, 0) * F(0) + F(3) * C(3, 3) * F(3) + S(0);
        answer(0, 1) = F(0) * C(0, 3) * F(4) + F(0) * C(0, 1) * F(1) + F(3) * C(3, 3) * F(4) + F(3) * C(3, 1) * F(1) + 0.0;
        answer(0, 2) = F(0) * C(0, 2) * F(2) + F(3) * C(3, 2) * F(2) + 0.0;
        answer(0, 3) = F(0) * C(0, 3) * F(0) + F(0) * C(0, 1) * F(3) + F(3) * C(3, 3) * F(0) + F(3) * C(3, 1) * F(3) + S(3);
        answer(0, 4) = F(0) * C(0, 0) * F(4) + F(0) * C(0, 3) * F(1) + F(3) * C(3, 0) * F(4) + F(3) * C(3, 3) * F(1) + 0.0;
        answer(1, 0) = F(4) * C(3, 0) * F(0) + F(4) * C(3, 3) * F(3) + F(1) * C(1, 0) * F(0) + F(1) * C(1, 3) * F(3) + 0.0;
        answer(1, 1) = F(4) * C(3, 3) * F(4) + F(4) * C(3, 1) * F(1) + F(1) * C(1, 3) * F(4) + F(1) * C(1, 1) * F(1) + S(1);
        answer(1, 2) = F(4) * C(3, 2) * F(2) + F(1) * C(1, 2) * F(2) + 0.0;
        answer(1, 3) = F(4) * C(3, 3) * F(0) + F(4) * C(3, 1) * F(3) + F(1) * C(1, 3) * F(0) + F(1) * C(1, 1) * F(3) + 0.0;
        answer(1, 4) = F(4) * C(3, 0) * F(4) + F(4) * C(3, 3) * F(1) + F(1) * C(1, 0) * F(4) + F(1) * C(1, 3) * F(1) + S(3);
        answer(2, 0) = F(2) * C(2, 0) * F(0) + F(2) * C(2, 3) * F(3) + 0.0;
        answer(2, 1) = F(2) * C(2, 3) * F(4) + F(2) * C(2, 1) * F(1) + 0.0;
        answer(2, 2) = F(2) * C(2, 2) * F(2) + S(2);
        answer(2, 3) = F(2) * C(2, 3) * F(0) + F(2) * C(2, 1) * F(3) + 0.0;
        answer(2, 4) = F(2) * C(2, 0) * F(4) + F(2) * C(2, 3) * F(1) + 0.0;
        answer(3, 0) = F(0) * C(3, 0) * F(0) + F(0) * C(3, 3) * F(3) + F(3) * C(1, 0) * F(0) + F(3) * C(1, 3) * F(3) + S(3);
        answer(3, 1) = F(0) * C(3, 3) * F(4) + F(0) * C(3, 1) * F(1) + F(3) * C(1, 3) * F(4) + F(3) * C(1, 1) * F(1) + 0.0;
        answer(3, 2) = F(0) * C(3, 2) * F(2) + F(3) * C(1, 2) * F(2) + 0.0;
        answer(3, 3) = F(0) * C(3, 3) * F(0) + F(0) * C(3, 1) * F(3) + F(3) * C(1, 3) * F(0) + F(3) * C(1, 1) * F(3) + S(1);
        answer(3, 4) = F(0) * C(3, 0) * F(4) + F(0) * C(3, 3) * F(1) + F(3) * C(1, 0) * F(4) + F(3) * C(1, 3) * F(1) + 0.0;
        answer(4, 0) = F(4) * C(0, 0) * F(0) + F(4) * C(0, 3) * F(3) + F(1) * C(3, 0) * F(0) + F(1) * C(3, 3) * F(3) + 0.0;
        answer(4, 1) = F(4) * C(0, 3) * F(4) + F(4) * C(0, 1) * F(1) + F(1) * C(3, 3) * F(4) + F(1) * C(3, 1) * F(1) + S(3);
        answer(4, 2) = F(4) * C(0, 2) * F(2) + F(1) * C(3, 2) * F(2) + 0.0;
        answer(4, 3) = F(4) * C(0, 3) * F(0) + F(4) * C(0, 1) * F(3) + F(1) * C(3, 3) * F(0) + F(1) * C(3, 1) * F(3) + 0.0;
        answer(4, 4) = F(4) * C(0, 0) * F(4) + F(4) * C(0, 3) * F(1) + F(1) * C(3, 0) * F(4) + F(1) * C(3, 3) * F(1) + S(0);
    } else if ( matMode == _1dMat ) {
        //Save terms associated with H = [du/dx]
        /// @todo is this really correct??

        answer.resize(1, 1);
        answer(0, 0) = F(0) * C(0, 0) * F(0) + S(0);
    } else if ( matMode == _Membrane2d ) {
      FloatArray mS(S);
      //Save terms associated with H = [du/dx, dv/dy, du/dy, dw/dy, dw/dx, dv/dx]
      if(S.at(1) == 0 && S.at(2) == 0 ) {
	mS.at(1) = 1;
	mS.at(2) = 1;
      }
	
      answer.resize(6, 6);
      answer(0, 0) = F(0) * C(0, 0) * F(0) + F(0) * C(0, 2) * F(2) + F(2) * C(2, 0) * F(0) + F(2) * C(2, 2) * F(2) + mS(0);
      answer(0, 1) = F(0) * C(0, 2) * F(5) + F(0) * C(0, 1) * F(1) + F(2) * C(2, 2) * F(5) + F(2) * C(2, 1) * F(1) + 0.0;
      answer(0, 2) = F(0) * C(0, 2) * F(0) + F(0) * C(0, 1) * F(2) + F(2) * C(2, 2) * F(0) + F(2) * C(2, 1) * F(2) + mS(2);
      answer(0, 3) = F(0) * C(0, 2) * F(4) + F(0) * C(0, 1) * F(3) + F(2) * C(2, 2) * F(4) + F(2) * C(2, 1) * F(3) + 0.0;
      answer(0, 4) = F(0) * C(0, 0) * F(4) + F(0) * C(0, 2) * F(3) + F(2) * C(2, 0) * F(4) + F(2) * C(2, 2) * F(3) + 0.0;
      answer(0, 5) = F(0) * C(0, 0) * F(5) + F(0) * C(0, 2) * F(1) + F(2) * C(2, 0) * F(5) + F(2) * C(2, 2) * F(1) + 0.0;
      
      answer(1, 0) = F(5) * C(2, 0) * F(0) + F(5) * C(2, 2) * F(2) + F(1) * C(1, 0) * F(0) + F(1) * C(1, 2) * F(2) + 0.0;
      answer(1, 1) = F(5) * C(2, 2) * F(5) + F(5) * C(2, 1) * F(1) + F(1) * C(1, 2) * F(5) + F(1) * C(1, 1) * F(1) + mS(1);
      answer(1, 2) = F(5) * C(2, 2) * F(0) + F(5) * C(2, 1) * F(2) + F(1) * C(1, 2) * F(0) + F(1) * C(1, 1) * F(2) + 0.0;
      answer(1, 3) = F(5) * C(2, 2) * F(4) + F(5) * C(2, 1) * F(3) + F(1) * C(1, 2) * F(4) + F(1) * C(1, 1) * F(3) + 0.0;
      answer(1, 4) = F(5) * C(2, 0) * F(4) + F(5) * C(2, 2) * F(3) + F(1) * C(1, 0) * F(4) + F(1) * C(1, 2) * F(3) + 0.0;
      answer(1, 5) = F(5) * C(2, 0) * F(5) + F(5) * C(2, 2) * F(1) + F(1) * C(1, 0) * F(5) + F(1) * C(1, 2) * F(1) + mS(2);
      
      answer(2, 0) = F(0) * C(2, 0) * F(0) + F(0) * C(2, 2) * F(2) + F(2) * C(1, 0) * F(0) + F(2) * C(1, 2) * F(2) + mS(2);
      answer(2, 1) = F(0) * C(2, 2) * F(5) + F(0) * C(2, 1) * F(1) + F(2) * C(1, 2) * F(5) + F(2) * C(1, 1) * F(1) + 0.0;
      answer(2, 2) = F(0) * C(2, 2) * F(0) + F(0) * C(2, 1) * F(2) + F(2) * C(1, 2) * F(0) + F(2) * C(1, 1) * F(2) + mS(1);
      answer(2, 3) = F(0) * C(2, 2) * F(4) + F(0) * C(2, 1) * F(3) + F(2) * C(1, 2) * F(4) + F(2) * C(1, 1) * F(3) + 0.0;
      answer(2, 4) = F(0) * C(2, 0) * F(4) + F(0) * C(2, 2) * F(3) + F(2) * C(1, 0) * F(4) + F(2) * C(1, 2) * F(3) + 0.0;
      answer(2, 5) = F(0) * C(2, 0) * F(5) + F(0) * C(2, 2) * F(1) + F(2) * C(1, 0) * F(5) + F(2) * C(1, 2) * F(1) + 0.0;
      
      answer(3, 0) = F(4) * C(2, 0) * F(0) + F(4) * C(2, 2) * F(2) + F(3) * C(1, 0) * F(0) + F(3) * C(1, 2) * F(2) + 0.0;
      answer(3, 1) = F(4) * C(2, 2) * F(5) + F(4) * C(2, 1) * F(1) + F(3) * C(1, 2) * F(5) + F(3) * C(1, 1) * F(1) + 0.0;
      answer(3, 2) = F(4) * C(2, 2) * F(0) + F(4) * C(2, 1) * F(2) + F(3) * C(1, 2) * F(0) + F(3) * C(1, 1) * F(2) + 0.0;
      answer(3, 3) = F(4) * C(2, 2) * F(4) + F(4) * C(2, 1) * F(3) + F(3) * C(1, 2) * F(4) + F(3) * C(1, 1) * F(3) + mS(1);
      answer(3, 4) = F(4) * C(2, 0) * F(4) + F(4) * C(2, 2) * F(3) + F(3) * C(1, 0) * F(4) + F(3) * C(1, 2) * F(3) + mS(2);
      answer(3, 5) = F(4) * C(2, 0) * F(5) + F(4) * C(2, 2) * F(1) + F(3) * C(1, 0) * F(5) + F(3) * C(1, 2) * F(1) + 0.0;
      
      answer(4, 0) = F(4) * C(0, 0) * F(0) + F(4) * C(0, 2) * F(2) + F(3) * C(2, 0) * F(0) + F(3) * C(2, 2) * F(2) + 0.0;
      answer(4, 1) = F(4) * C(0, 2) * F(5) + F(4) * C(0, 1) * F(1) + F(3) * C(2, 2) * F(5) + F(3) * C(2, 1) * F(1) + 0.0;
      answer(4, 2) = F(4) * C(0, 2) * F(0) + F(4) * C(0, 1) * F(2) + F(3) * C(2, 2) * F(0) + F(3) * C(2, 1) * F(2) + 0.0;
      answer(4, 3) = F(4) * C(0, 2) * F(4) + F(4) * C(0, 1) * F(3) + F(3) * C(2, 2) * F(4) + F(3) * C(2, 1) * F(3) + mS(2);
      answer(4, 4) = F(4) * C(0, 0) * F(4) + F(4) * C(0, 2) * F(3) + F(3) * C(2, 0) * F(4) + F(3) * C(2, 2) * F(3) + mS(0);
      answer(4, 5) = F(4) * C(0, 0) * F(5) + F(4) * C(0, 2) * F(1) + F(3) * C(2, 0) * F(5) + F(3) * C(2, 2) * F(1) + 0.0;

      answer(5, 0) = F(5) * C(0, 0) * F(0) + F(5) * C(0, 2) * F(2) + F(1) * C(2, 0) * F(0) + F(1) * C(2, 2) * F(2) + 0.0;
      answer(5, 1) = F(5) * C(0, 2) * F(5) + F(5) * C(0, 1) * F(1) + F(1) * C(2, 2) * F(5) + F(1) * C(2, 1) * F(1) + mS(2);
      answer(5, 2) = F(5) * C(0, 2) * F(0) + F(5) * C(0, 1) * F(2) + F(1) * C(2, 2) * F(0) + F(1) * C(2, 1) * F(2) + 0.0;
      answer(5, 3) = F(5) * C(0, 2) * F(4) + F(5) * C(0, 1) * F(3) + F(1) * C(2, 2) * F(4) + F(1) * C(2, 1) * F(3) + 0.0;
      answer(5, 4) = F(5) * C(0, 0) * F(4) + F(5) * C(0, 2) * F(3) + F(1) * C(2, 0) * F(4) + F(1) * C(2, 2) * F(3) + 0.0;
      answer(5, 5) = F(5) * C(0, 0) * F(5) + F(5) * C(0, 2) * F(1) + F(1) * C(2, 0) * F(5) + F(1) * C(2, 2) * F(1) + mS(0);

      
    }

}

void
StructuralMaterial :: giveEshelbyStressVector_PlaneStrain(FloatArray &answer, GaussPoint *gp, const FloatArray &reducedF, TimeStep *tStep)
{
    OOFEM_ERROR("not implemented ")
}

void
StructuralMaterial :: give_dPdF_from(const FloatMatrix &dSdE, FloatMatrix &answer, GaussPoint *gp, MaterialMode matMode)
{
    // Default implementation for converting dSdE to dPdF. This includes updating the
    // state variables of P and F.
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );
    FloatArray reducedvF, reducedvP, reducedvS;
    const FloatArray &vF = status->giveTempFVector();
    const FloatArray &vP = status->giveTempPVector();
    const FloatArray &vS = status->giveTempStressVector();

    //    MaterialMode matMode = gp->giveMaterialMode();
    ///@todo This is unnecessary and inefficient, just a hack for now (it will be changed when everything is in working order!)
    StructuralMaterial :: giveReducedVectorForm(reducedvF, vF, matMode);
    StructuralMaterial :: giveReducedVectorForm(reducedvP, vP, matMode);
    StructuralMaterial :: giveReducedSymVectorForm(reducedvS, vS, matMode);
    //this->convert_P_2_mS(reducedvS, reducedvP, reducedvF, matMode);
    this->convert_dSdE_2_dPdF(answer, dSdE, reducedvS, reducedvF, matMode);
}


void
StructuralMaterial :: giveStiffnessMatrix(FloatMatrix &answer,
                                          MatResponseMode rMode,
                                          GaussPoint *gp, TimeStep *tStep)
//
// Returns characteristic material stiffness matrix of the receiver
//
{
    MaterialMode mMode = gp->giveMaterialMode();
    switch ( mMode ) {
    case _3dMat:
        this->give3dMaterialStiffnessMatrix(answer, rMode, gp, tStep);
        break;
    case _PlaneStress:
        this->givePlaneStressStiffMtrx(answer, rMode, gp, tStep);
        break;
    case _PlaneStrain:
        this->givePlaneStrainStiffMtrx(answer, rMode, gp, tStep);
        break;
    case _1dMat:
        this->give1dStressStiffMtrx(answer, rMode, gp, tStep);
        break;

    case _PlateLayer:
        this->givePlateLayerStiffMtrx(answer, rMode, gp, tStep);
        break;
    case _2dBeamLayer:
        this->give2dBeamLayerStiffMtrx(answer, rMode, gp, tStep);
        break;
    case _Fiber:
        this->giveFiberStiffMtrx(answer, rMode, gp, tStep);
        break;
    case _Warping:
        answer.resize(2, 2);
        answer.beUnitMatrix();
        break;
    case _2dLattice:
        this->give2dLatticeStiffMtrx(answer, rMode, gp, tStep);
        break;
    case _3dLattice:
        this->give3dLatticeStiffMtrx(answer, rMode, gp, tStep);
        break;

    case _AxisymMemebrane1d:
        this->giveStiffnessMatrix_AxisymMembrane1d(answer, rMode, gp, tStep);
	break;
	
    case _Membrane2d:
        this->give3dMaterialStiffnessMatrix(answer, rMode, gp, tStep);
	break;



    default:
        OOFEM_ERROR( "unknown mode (%s)", __MaterialModeToString(mMode) );
    }
}


void
StructuralMaterial :: give3dMaterialStiffnessMatrix_dPdF(FloatMatrix &answer,
                                                         MatResponseMode mode,
                                                         GaussPoint *gp, TimeStep *tStep)
{
    FloatMatrix dSdE;
    this->give3dMaterialStiffnessMatrix(dSdE, mode, gp, tStep);
    this->give_dPdF_from(dSdE, answer, gp, _3dMat);
}


void
StructuralMaterial :: givePlaneStressStiffMtrx_dPdF(FloatMatrix &answer,
                                                    MatResponseMode mode,
                                                    GaussPoint *gp, TimeStep *tStep)
{
    FloatMatrix dSdE;
    this->givePlaneStressStiffMtrx(dSdE, mode, gp, tStep);
    this->give_dPdF_from(dSdE, answer, gp, _PlaneStress);
}



void
StructuralMaterial :: giveMembrane2dStiffMtrx_dPdF(FloatMatrix &answer,
                                                    MatResponseMode mode,
                                                    GaussPoint *gp, TimeStep *tStep)
{
    FloatMatrix dSdE;
    this->givePlaneStressStiffMtrx(dSdE, mode, gp, tStep);
    this->give_dPdF_from(dSdE, answer, gp, _Membrane2d);
}


void
StructuralMaterial :: givePlaneStrainStiffMtrx_dPdF(FloatMatrix &answer,
                                                    MatResponseMode mode,
                                                    GaussPoint *gp, TimeStep *tStep)
{
    FloatMatrix m3d;

    this->give3dMaterialStiffnessMatrix_dPdF(m3d, mode, gp, tStep);

    answer.resize(5, 5);
    answer.zero();
    //answer.beSubMatrixOf(m3d, indx, indx);

    answer.at(1, 1) = m3d.at(1, 1);
    answer.at(1, 2) = m3d.at(1, 2);
    answer.at(1, 4) = m3d.at(1, 6);
    answer.at(1, 5) = m3d.at(1, 9);

    answer.at(2, 1) = m3d.at(2, 1);
    answer.at(2, 2) = m3d.at(2, 2);
    answer.at(2, 4) = m3d.at(2, 6);
    answer.at(2, 5) = m3d.at(2, 9);

    answer.at(3, 1) = m3d.at(3, 1);
    answer.at(3, 2) = m3d.at(3, 2);
    answer.at(3, 4) = m3d.at(3, 6);
    answer.at(3, 5) = m3d.at(3, 9);

    answer.at(4, 1) = m3d.at(6, 1);
    answer.at(4, 2) = m3d.at(6, 2);
    answer.at(4, 4) = m3d.at(6, 6);
    answer.at(4, 5) = m3d.at(6, 9);

    answer.at(5, 1) = m3d.at(9, 1);
    answer.at(5, 2) = m3d.at(9, 2);
    answer.at(5, 4) = m3d.at(9, 6);
    answer.at(5, 5) = m3d.at(9, 9);
    
}


void
StructuralMaterial :: give1dStressStiffMtrx_dPdF(FloatMatrix &answer,
                                                 MatResponseMode mode,
                                                 GaussPoint *gp, TimeStep *tStep)
{
    FloatMatrix dSdE;
    this->give1dStressStiffMtrx(dSdE, mode, gp, tStep);
    this->give_dPdF_from(dSdE, answer, gp, _1dMat);
}




void
StructuralMaterial :: giveSpatial3dMaterialStiffnessMatrix(FloatMatrix &answer,
                                                         MatResponseMode mode,
                                                         GaussPoint *gp, TimeStep *tStep)
{
    ///@todo what should be default implementaiton?
    OOFEM_ERROR("There is no default implementation");
}


void
StructuralMaterial :: giveSpatialPlaneStressStiffMtrx(FloatMatrix &answer,
                                                    MatResponseMode mode,
                                                    GaussPoint *gp, TimeStep *tStep)
{
    OOFEM_ERROR("There is no default implementation");
}


void
StructuralMaterial :: giveSpatialPlaneStrainStiffMtrx(FloatMatrix &answer,
                                                    MatResponseMode mode,
                                                    GaussPoint *gp, TimeStep *tStep)
{

    FloatMatrix m3d;

    this->giveSpatial3dMaterialStiffnessMatrix(m3d, mode, gp, tStep);

    answer.resize(4, 4);
    answer.zero();
    //answer.beSubMatrixOf(m3d, indx, indx);

    answer.at(1, 1) = m3d.at(1, 1);
    answer.at(1, 2) = m3d.at(1, 2);
    answer.at(1, 4) = m3d.at(1, 6);

    answer.at(2, 1) = m3d.at(2, 1);
    answer.at(2, 2) = m3d.at(2, 2);
    answer.at(2, 4) = m3d.at(2, 6);

    answer.at(3, 1) = m3d.at(3, 1);
    answer.at(3, 2) = m3d.at(3, 2);
    answer.at(3, 4) = m3d.at(3, 6);

    answer.at(4, 1) = m3d.at(6, 1);
    answer.at(4, 2) = m3d.at(6, 2);
    answer.at(4, 4) = m3d.at(6, 6);

}


void
StructuralMaterial :: giveSpatial1dStressStiffMtrx(FloatMatrix &answer,
                                                 MatResponseMode mode,
                                                 GaussPoint *gp, TimeStep *tStep)
{
    OOFEM_ERROR("There is no default implementation");
}



void
StructuralMaterial :: giveInitialStiffnessMatrix_Cauchy(FloatMatrix &answer,
                                                  MatResponseMode mode,
                                                 GaussPoint *gp, TimeStep *tStep)
{
   StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );
   FloatArray redvCauchy, vCauchy;
   redvCauchy = status->giveTempCVector();
   FloatMatrix stress_ident(9,9);

   if ( redvCauchy.giveSize() ) {
     StructuralMaterial :: giveFullSymVectorForm( vCauchy, redvCauchy, gp->giveMaterialMode() );
     // product Cauchy_il delta_jk
     /*
       [ sig11,     0,     0,     0, sig13, sig12,     0,     0,     0]
       [     0, sig22,     0, sig23,     0,     0,     0,     0, sig21]
       [     0,     0, sig33,     0,     0,     0, sig32, sig31,     0]
       [     0, sig32,     0, sig33,     0,     0,     0,     0, sig31]
       [ sig31,     0,     0,     0, sig33, sig32,     0,     0,     0]
       [ sig21,     0,     0,     0, sig23, sig22,     0,     0,     0]
       [     0,     0, sig23,     0,     0,     0, sig22, sig21,     0]
       [     0,     0, sig13,     0,     0,     0, sig12, sig11,     0]
       [     0, sig12,     0, sig13,     0,     0,     0,     0, sig11]
     */
	 stress_ident.at(1, 1) = vCauchy.at(1);
	 stress_ident.at(1, 5) = vCauchy.at(5);
	 stress_ident.at(1, 6) = vCauchy.at(6);

	 stress_ident.at(2, 2) = vCauchy.at(2);
	 stress_ident.at(2, 4) = vCauchy.at(4);
	 stress_ident.at(2, 9) = vCauchy.at(6);

	 stress_ident.at(3, 3) = vCauchy.at(3);
	 stress_ident.at(3, 7) = vCauchy.at(4);
	 stress_ident.at(3, 8) = vCauchy.at(5);

	 stress_ident.at(4, 2) = vCauchy.at(4);
	 stress_ident.at(4, 4) = vCauchy.at(3);
	 stress_ident.at(4, 9) = vCauchy.at(5);

	 stress_ident.at(5, 1) = vCauchy.at(5);
	 stress_ident.at(5, 5) = vCauchy.at(3);
	 stress_ident.at(5, 6) = vCauchy.at(4);

	 stress_ident.at(6, 1) = vCauchy.at(6);
	 stress_ident.at(6, 5) = vCauchy.at(4);
	 stress_ident.at(6, 6) = vCauchy.at(2);

	 stress_ident.at(7, 3) = vCauchy.at(4);
	 stress_ident.at(7, 7) = vCauchy.at(2);
	 stress_ident.at(7, 8) = vCauchy.at(6);

	 stress_ident.at(8, 3) = vCauchy.at(5);
	 stress_ident.at(8, 7) = vCauchy.at(6);
	 stress_ident.at(8, 8) = vCauchy.at(1);

	 stress_ident.at(9, 2) = vCauchy.at(6);
	 stress_ident.at(9, 4) = vCauchy.at(5);
	 stress_ident.at(9, 9) = vCauchy.at(1);
   } else {
     stress_ident.zero();
   }
     IntArray indx;
     StructuralMaterial :: giveVoigtVectorMask(indx,gp->giveMaterialMode());
     answer.beSubMatrixOf(stress_ident, indx, indx);
     answer.symmetrized();
    
}



void
StructuralMaterial :: giveStressDependentPartOfStrainVector(FloatArray &answer, GaussPoint *gp,
                                                            const FloatArray &reducedStrainVector,
                                                            TimeStep *tStep, ValueModeType mode)
{
    /*
     * This functions subtract from reducedStrainVector its stress independent part
     * caused by temperature, shrinkage and possibly by other phenomena.
     */
    FloatArray epsilonTemperature;

    answer = reducedStrainVector;
    this->computeStressIndependentStrainVector(epsilonTemperature, gp, tStep, mode);
    if ( epsilonTemperature.giveSize() ) {
        answer.subtract(epsilonTemperature);
    }
}


int
StructuralMaterial :: giveSizeOfVoigtSymVector(MaterialMode mode)
{
    IntArray indx;
    StructuralMaterial :: giveVoigtSymVectorMask(indx, mode);
    return indx.giveSize();
}


int
StructuralMaterial :: giveSizeOfVoigtVector(MaterialMode mode)
{
    IntArray indx;
    StructuralMaterial :: giveVoigtVectorMask(indx, mode);
    return indx.giveSize();
}


void
StructuralMaterial :: giveInvertedVoigtVectorMask(IntArray &answer, MaterialMode mmode)
{
    IntArray mask;
    answer.resize( StructuralMaterial :: giveVoigtSymVectorMask(mask, mmode) );
    answer.zero();
    for ( int i = 1; i <= mask.giveSize(); i++ ) {
        answer.at( mask.at(i) ) = i;
    }
}


int
StructuralMaterial :: giveVoigtSymVectorMask(IntArray &answer, MaterialMode mmode)
{
    // The same as giveVoigtVectorMask but returns a mask corresponding to a symmetric
    // second order tensor.
    //
    // Returns a mask of the vector indices corresponding to components in a symmetric
    // second order tensor of some stress/strain/deformation measure that performs work.
    // Thus, components corresponding to imposed zero stress (e.g. plane stress etc.) are
    // not included. On the other hand, if zero strain components are imposed( e.g. plane
    // strain etc.) this condition must be taken into account in geometrical relations.
    // Therefore, these corresponding components are included in the reduced vector.
    // Which components to include are given by the particular MaterialMode.

    switch ( mmode ) {
    case _3dMat:
    case _3dMicroplane:
        answer.enumerate(6);
        return 6;

    case _3dDegeneratedShell:
        answer = {
            1, 2, 3, 4, 5, 6
        };
        return 6;


    case _PlaneStress:
        answer = {
            1, 2, 6
        };
        return 6;

    case _PlaneStrain:
        answer = {
            1, 2, 3, 6
        };
        return 6;

    case _1dMat:
        answer = {
            1
        };
        return 6;

    case _Warping:
        answer = {
            4, 5
        };
        return 6;

    case _PlateLayer:
        answer = {
            1, 2, 4, 5, 6
        };
        return 6;

    case _2dBeamLayer:
        answer = {
            1, 5
        };
        return 6;

    case _Fiber:
        answer = {
            1, 5, 6
        };
        return 6;

    case _2dPlate:
        answer = {
            4, 5, 6, 7, 8
        };
        return 8;

    case _2dBeam:
        answer = {
            1, 4, 7
        };
        return 8;

    case _3dBeam: ///@todo This isn't actually fixed yet. Should be made compatible with 3dShell and 2dBeam
#if 1
        answer.enumerate(6);
        return 6;

#else
        answer = {
            1, 5, 6, 7, 8, 9
        };
        return 12;

#endif
    case _3dShell:
        answer.enumerate(8);
        return 8;

    case _PlaneStressRot:
        answer = {
            1, 2, 6, 7
        };
        return 7;

    case _1dInterface:
        answer = {
            1
        };
        return 1;

    case _2dInterface:
        answer = {
            1, 2
        };
        return 2;

    case _3dInterface:
        answer = {
            1, 2, 3
        };
        return 3;

    case _2dLattice:
        answer = {
            1, 2, 3
        };
        return 3;

    case _3dLattice:
        answer = {
            1, 2, 3, 4, 5, 6
        };
        return 6;

    case _2dPlateSubSoil:
        answer = {
            3, 5, 4
        };
        return 6;

    case _3dBeamSubSoil: ///@todo This isn't actually fixed yet. Should be made compatible with 3dShell and 2dBeam
#if 1
        answer.enumerate(6);
        return 6;

#else
        answer = {
            1, 5, 6, 7, 8, 9
        };
        return 12;
#endif
	
    case _Unknown:
        answer.clear();
        return 0;

    case _AxisymMemebrane1d:
      answer = {
	1, 2
      };
      return 2;

	
    case _Membrane2d:
        answer = {
	  1, 2, 6
        };
        return 6;


    default:
        return 0;
    }
}


int
StructuralMaterial :: giveVoigtVectorMask(IntArray &answer, MaterialMode mmode)
{
    // Returns a mask of the vector indices corresponding to components in a general
    // (non-symmetric) second order tensor of some stress/strain/deformation measure that
    // performs work. Thus, components corresponding to imposed zero stress (e.g. plane
    // stress etc.) are not included. On the other hand, if zero strain components are
    // imposed( e.g. plane strain etc.) this condition must be taken into account in
    // geometrical relations. Therefore, these corresponding components are included in
    // the reduced vector. Which components to include are given by the particular MaterialMode.
    //
    /// @todo add additional modes if they relevant.

    switch ( mmode ) {
    case _3dMat:
        answer.resize(9);
        for ( int i = 1; i <= 9; i++ ) {
            answer.at(i) = i;
        }

        return 9;

    case _PlaneStress:
        answer.resize(4);
        answer.at(1) = 1;
        answer.at(2) = 2;
        answer.at(3) = 6;
        answer.at(4) = 9;
        return 9;

    case _PlaneStrain:
        answer.resize(5);
        answer.at(1) = 1;
        answer.at(2) = 2;
        answer.at(3) = 3;
        answer.at(4) = 6;
        answer.at(5) = 9;
        return 9;

    case _1dMat:
        answer.resize(1);
        answer.at(1) = 1;
        return 9;

    case _Membrane2d:
        answer = {
	  1, 2, 6, 7, 8, 9
        };
        return 9;
    default:
        return 0;
    }
}


void
StructuralMaterial :: givePlaneStressStiffMtrx(FloatMatrix &answer,
                                               MatResponseMode mode,
                                               GaussPoint *gp,
                                               TimeStep *tStep)
//
// returns Mat stiffness for PlaneStress
//
{
    FloatMatrix m3d, invMat3d, invAnswer;

    this->give3dMaterialStiffnessMatrix(m3d, mode, gp, tStep);

    invMat3d.beInverseOf(m3d);

    invAnswer.resize(3, 3);
    //invAnswer.beSubMatrixOf(invMat3d, indx, indx);

    invAnswer.at(1, 1) = invMat3d.at(1, 1);
    invAnswer.at(1, 2) = invMat3d.at(1, 2);
    invAnswer.at(1, 3) = invMat3d.at(1, 6);

    invAnswer.at(2, 1) = invMat3d.at(2, 1);
    invAnswer.at(2, 2) = invMat3d.at(2, 2);
    invAnswer.at(2, 3) = invMat3d.at(2, 6);

    invAnswer.at(3, 1) = invMat3d.at(6, 1);
    invAnswer.at(3, 2) = invMat3d.at(6, 2);
    invAnswer.at(3, 3) = invMat3d.at(6, 6);

    answer.beInverseOf(invAnswer);
}

void
StructuralMaterial :: givePlaneStrainStiffMtrx(FloatMatrix &answer,
                                               MatResponseMode mode,
                                               GaussPoint *gp,
                                               TimeStep *tStep)
//
// return material stiffness matrix for PlaneStrain mode
//
{
    FloatMatrix m3d;

    this->give3dMaterialStiffnessMatrix(m3d, mode, gp, tStep);

    answer.resize(4, 4);
    answer.zero();
    //answer.beSubMatrixOf(m3d, indx, indx);

    answer.at(1, 1) = m3d.at(1, 1);
    answer.at(1, 2) = m3d.at(1, 2);
    answer.at(1, 4) = m3d.at(1, 6);

    answer.at(2, 1) = m3d.at(2, 1);
    answer.at(2, 2) = m3d.at(2, 2);
    answer.at(2, 4) = m3d.at(2, 6);

    answer.at(3, 1) = m3d.at(3, 1);
    answer.at(3, 2) = m3d.at(3, 2);
    answer.at(3, 4) = m3d.at(3, 6);

    answer.at(4, 1) = m3d.at(6, 1);
    answer.at(4, 2) = m3d.at(6, 2);
    answer.at(4, 4) = m3d.at(6, 6);
}

void
StructuralMaterial :: give1dStressStiffMtrx(FloatMatrix &answer,
                                            MatResponseMode mode,
                                            GaussPoint *gp,
                                            TimeStep *tStep)
//
// return material stiffness matrix for 1d stress strain mode
//
{
    FloatMatrix m3d, invMat3d;
    double val11;

    this->give3dMaterialStiffnessMatrix(m3d, mode, gp, tStep);

    invMat3d.beInverseOf(m3d);
    val11 = invMat3d.at(1, 1);
    answer.resize(1, 1);
    answer.at(1, 1) = 1. / val11;
}


void
StructuralMaterial :: give2dBeamLayerStiffMtrx(FloatMatrix &answer,
                                               MatResponseMode mode,
                                               GaussPoint *gp,
                                               TimeStep *tStep)
//
// return material stiffness matrix for2dBeamLayer mode
//
{
    FloatMatrix m3d, invMat3d, invMatLayer(2, 2);

    this->give3dMaterialStiffnessMatrix(m3d, mode, gp, tStep);

    invMat3d.beInverseOf(m3d);

    invMatLayer.at(1, 1) = invMat3d.at(1, 1);
    invMatLayer.at(1, 2) = invMat3d.at(1, 5);
    invMatLayer.at(2, 1) = invMat3d.at(5, 1);
    invMatLayer.at(2, 2) = invMat3d.at(5, 5);

    answer.beInverseOf(invMatLayer);
}


void
StructuralMaterial :: givePlateLayerStiffMtrx(FloatMatrix &answer,
                                              MatResponseMode mode,
                                              GaussPoint *gp,
                                              TimeStep *tStep)
//
// return material stiffness matrix for 2dPlateLayer
//
{
    FloatMatrix m3d, invMat3d, invMatLayer(5, 5);

    this->give3dMaterialStiffnessMatrix(m3d, mode, gp, tStep);

    invMat3d.beInverseOf(m3d);
    //invMatLayer.beSubMatrixOf(invMat3d, indx, indx);

    for ( int i = 1; i <= 2; i++ ) {
        for ( int j = 1; j <= 2; j++ ) {
            invMatLayer.at(i, j) = invMat3d.at(i, j);
        }
    }

    for ( int i = 4; i <= 6; i++ ) {
        for ( int j = 4; j <= 6; j++ ) {
            invMatLayer.at(i - 1, j - 1) = invMat3d.at(i, j);
        }
    }

    for ( int i = 1; i <= 2; i++ ) {
        for ( int j = 4; j <= 6; j++ ) {
            invMatLayer.at(i, j - 1) = invMat3d.at(i, j);
            invMatLayer.at(j - 1, i) = invMat3d.at(j, i);
        }
    }

    answer.beInverseOf(invMatLayer);
}

void
StructuralMaterial :: giveFiberStiffMtrx(FloatMatrix &answer,
                                         MatResponseMode mode,
                                         GaussPoint *gp,
                                         TimeStep *tStep)
//
// return material stiffness matrix for 2dPlateLayer
//
{
    FloatMatrix m3d, invMat3d, invMatLayer(3, 3);

    this->give3dMaterialStiffnessMatrix(m3d, mode, gp, tStep);

    invMat3d.beInverseOf(m3d);

    invMatLayer.at(1, 1) = invMat3d.at(1, 1);
    invMatLayer.at(1, 2) = invMat3d.at(1, 5);
    invMatLayer.at(1, 3) = invMat3d.at(1, 6);
    invMatLayer.at(2, 1) = invMat3d.at(5, 1);
    invMatLayer.at(2, 2) = invMat3d.at(5, 5);
    invMatLayer.at(2, 3) = invMat3d.at(5, 6);
    invMatLayer.at(3, 1) = invMat3d.at(6, 1);
    invMatLayer.at(3, 2) = invMat3d.at(6, 5);
    invMatLayer.at(3, 3) = invMat3d.at(6, 6);

    answer.beInverseOf(invMatLayer);
}

void
StructuralMaterial :: give2dLatticeStiffMtrx(FloatMatrix &answer,
                                             MatResponseMode mode,
                                             GaussPoint *gp,
                                             TimeStep *tStep)
//
// return material stiffness matrix for 2dlattice
//
{
    OOFEM_ERROR("No general implementation provided");
}

void
StructuralMaterial :: give3dLatticeStiffMtrx(FloatMatrix &answer,
                                             MatResponseMode mode,
                                             GaussPoint *gp,
                                             TimeStep *tStep)
//
// return material stiffness matrix for 2dlattice
//
{
    OOFEM_ERROR("No general implementation provided");
}


void
StructuralMaterial :: give2dPlateSubSoilStiffMtrx(FloatMatrix &answer,
                                                  MatResponseMode mmode, GaussPoint *gp,
                                                  TimeStep *tStep)
{
    OOFEM_ERROR("No general implementation provided");
}

void
StructuralMaterial :: give3dBeamSubSoilStiffMtrx(FloatMatrix &answer,
						 MatResponseMode mmode, GaussPoint *gp,
						 TimeStep *tStep)
{
    OOFEM_ERROR("No general implementation provided");
}


void StructuralMaterial :: giveStiffnessMatrix_AxisymMembrane1d(FloatMatrix &answer,
                                             MatResponseMode mmode, GaussPoint *gp,
                                             TimeStep *tStep)
{
    OOFEM_ERROR("No general implementation provided");
}

  


void
StructuralMaterial :: computePrincipalValues(FloatArray &answer, const FloatArray &s, stressStrainPrincMode mode)
//
// This function computes the principal values of strains or stresses.
// Strains/stresses are stored in vector form in array s.
// Engineering notation is used.
//
// Problem size (3D/2D) is recognized automatically according to the
// vector size.
// If size = 6 -> 3D problem, then array s contains:
//                            {Sxx,Syy,Szz,Syz,Szx,Sxy} if mode = principal_stress
//                            {Exx,Eyy,Ezz,GMyz,GMzx,GMxy} if mode = principal_strain
// if size = 3 -> 2D problem, then array s contains:
//                            {Sxx,Syy,Sxy} if mode = principal_stress
//                            {Exx,Eyy,GMxy} if mode = principal_strain
//
// if size = 4 -> 2D problem (with normal out-of-plane component), then array s contains:
//                            {Sxx,Syy,Szz,Sxy} if mode = principal_stress
//                            {Exx,Eyy,Ezz,GMxy} if mode = principal_strain
//
// Return Values:
//
//    array answer -> principal strains or stresses
//
{
    int size = s.giveSize();
    if ( !( ( size == 3 ) || ( size == 4 ) || ( size == 6 ) ) ) {
        OOFEM_SERROR("Vector size mismatch");
    }

    double swap;
    int nonzeroFlag = 0;
    bool solve = true;
    if ( ( size == 3 ) || ( size == 4 ) ) {
        // 2D problem
        double ast, dst, D = 0.0;
        answer.resize(size - 1);

        for ( int i = 1; i <= size; i++ ) {
            if ( fabs( s.at(i) ) > 1.e-20 ) {
                nonzeroFlag = 1;
            }
        }

        if ( nonzeroFlag == 0 ) {
            answer.zero();
            return;
        }

        ast = s.at(1) + s.at(2);
        dst = s.at(1) - s.at(2);
        if ( mode == principal_strain ) {
            D = dst * dst + s.at(size) * s.at(size);
        } else if ( mode == principal_stress ) {
            D = dst * dst + 4.0 * s.at(size) * s.at(size);
        } else {
            OOFEM_SERROR("not supported");
        }

        if ( D < 0. ) {
            OOFEM_SERROR("Imaginary roots ");
        }

        D = sqrt(D);
        answer.at(1) = 0.5 * ( ast - D );
        answer.at(2) = 0.5 * ( ast + D );
        if ( size == 4 ) {
            answer.at(3) = s.at(3);
        }
    } else {
        // 3D problem
        double I1 = 0.0, I2 = 0.0, I3 = 0.0, help, s1, s2, s3;

        for ( int i = 1; i <= size; i++ ) {
            if ( fabs( s.at(i) ) > 1.e-20 ) {
                nonzeroFlag = 1;
            }
        }

        answer.resize(3);
        answer.zero();
        if ( nonzeroFlag == 0 ) {
            return;
        }

        if ( mode == principal_stress ) {
            I1 = s.at(1) + s.at(2) + s.at(3);
            I2 = s.at(1) * s.at(2) + s.at(2) * s.at(3) + s.at(3) * s.at(1) -
                 ( s.at(4) * s.at(4) + s.at(5) * s.at(5) + s.at(6) * s.at(6) );
            I3 = s.at(1) * s.at(2) * s.at(3) + 2. * s.at(4) * s.at(5) * s.at(6) -
                 ( s.at(1) * s.at(4) * s.at(4) + s.at(2) * s.at(5) * s.at(5) +
                   s.at(3) * s.at(6) * s.at(6) );
        } else if ( mode == principal_deviatoricstress ) {
            help = ( s.at(1) + s.at(2) + s.at(3) ) / 3.0;
            I1 = 0.;
            I2 = -( 1. / 6. ) * ( ( s.at(1) - s.at(2) ) * ( s.at(1) - s.at(2) ) + ( s.at(2) - s.at(3) ) * ( s.at(2) - s.at(3) ) +
                                  ( s.at(3) - s.at(1) ) * ( s.at(3) - s.at(1) ) ) - s.at(4) * s.at(4) - s.at(5) * s.at(5) -
                 s.at(6) * s.at(6);
            I3 = ( s.at(1) - help ) * ( s.at(2) - help ) * ( s.at(3) - help ) + 2. * s.at(4) * s.at(5) * s.at(6) -
                 s.at(5) * s.at(5) * ( s.at(2) - help ) - s.at(4) * s.at(4) * ( s.at(1) - help ) -
                 s.at(6) * s.at(6) * ( s.at(3) - help );
        } else if ( mode == principal_strain ) {
            I1 = s.at(1) + s.at(2) + s.at(3);
            I2 = s.at(1) * s.at(2) + s.at(2) * s.at(3) + s.at(3) * s.at(1) -
                 0.25 * ( s.at(4) * s.at(4) + s.at(5) * s.at(5) + s.at(6) * s.at(6) );
            I3 = s.at(1) * s.at(2) * s.at(3) +
                 0.25 * ( s.at(4) * s.at(5) * s.at(6) - s.at(1) * s.at(4) * s.at(4) -
                          s.at(2) * s.at(5) * s.at(5) - s.at(3) * s.at(6) * s.at(6) );
        } else {
            OOFEM_SERROR("not supported");
        }

        /*
         * Call cubic3r to ensure that all three real eigenvalues will be found, because we have symmetric tensor.
         * This allows to overcome various rounding errors when solving general cubic equation.
         */
        int n;
        if ( solve ){
            cubic3r( ( double ) -1., I1, -I2, I3, & s1, & s2, & s3, & n );
        }

        if ( n > 0 ) {
            answer.at(1) = s1;
        }

        if ( n > 1 ) {
            answer.at(2) = s2;
        }

        if ( n > 2 ) {
            answer.at(3) = s3;
        }
    
         //Check NaN
//     if (answer.at(1)  != answer.at(1)) {
//         s.pY();
//         printf("%.10e %.10e %.10e\n", I1, I2, I3);
//         exit(0);
//     }
//         
        
        
    }

   
    
    
    
    //sort the results
    for ( int i = 1; i < answer.giveSize(); i++ ) {
        for ( int j = 1; j < answer.giveSize(); j++ ) {
            if ( answer.at(j + 1) > answer.at(j) ) {
                swap = answer.at(j + 1);
                answer.at(j + 1) = answer.at(j);
                answer.at(j) = swap;
            }
        }
    }
}

void
StructuralMaterial :: computePrincipalValDir(FloatArray &answer, FloatMatrix &dir,
                                             const FloatArray &s,
                                             stressStrainPrincMode mode)
//
// This function computes the principal values & directions corresponding to principal values
// of strains or streses.
// strains/streses are stored in vector form in array s.
// Engineering notation is used.
//
// Problem size (3D/2D) is recognized automatically according to
// vector size.
// If size = 6 -> 3D problem, then array s contains:
//                            {Sxx,Syy,Szz,Syz,Szx,Sxy} if mode = principal_stress
//                            {Exx,Eyy,Ezz,GMyz,GMzx,GMxy} if mode = principal_strain
// if size = 3 -> 2D problem, then array s contains:
//                            {Sxx,Syy,Sxy} if mode = principal_stress
//                            {Exx,Eyy,GMxy} if mode = principal_strain
//
// mode      - principal strains
//           - principal stress
//
// Input Values:
// mode
// s
//
// Return Values:
//
// matrix dir -> principal directions of strains or stresses
// array answer -> principal strains or stresses
//
{
    FloatMatrix ss;
    FloatArray sp;
    double swap;
    int nval, size = s.giveSize();
    int nonzeroFlag = 0;

    // printf ("size is %d\n",size);
    if ( !( ( size == 3 ) || ( size == 4 ) || ( size == 6 ) ) ) {
        OOFEM_SERROR("Vector size mismatch");
    }

    if ( ( size == 3 ) || ( size == 4 ) ) {
        // 2D problem
        ss.resize(2, 2);
        answer.resize(2);
        dir.resize(2, 2);

        for ( int i = 1; i <= size; i++ ) {
            if ( fabs( s.at(i) ) > 1.e-20 ) {
                nonzeroFlag = 1;
            }
        }

        if ( nonzeroFlag == 0 ) {
            answer.zero();
            dir.zero();
            ss.zero();
            return;
        }

        ss.at(1, 1) = s.at(1);
        ss.at(2, 2) = s.at(2);

        if ( mode == principal_strain ) {
            ss.at(1, 2) = ss.at(2, 1) = 0.5 * s.at(size);
        } else if ( mode == principal_stress ) {
            ss.at(1, 2) = ss.at(2, 1) = s.at(size);
        } else {
            OOFEM_SERROR("not supported");
        }
    } else {
        // 3D problem
        double help;
        ss.resize(3, 3);
        answer.resize(3);
        dir.resize(3, 3);

        for ( int i = 1; i <= size; i++ ) {
            if ( fabs( s.at(i) ) > 1.e-20 ) {
                nonzeroFlag = 1;
            }
        }

        if ( nonzeroFlag == 0 ) {
            answer.zero();
            dir.zero();
            ss.zero();
            return;
        }

        if ( mode == principal_stress ) {
            ss.at(1, 1) = s.at(1);
            ss.at(2, 2) = s.at(2);
            ss.at(3, 3) = s.at(3);
            ss.at(1, 2) = ss.at(2, 1) = s.at(6);
            ss.at(1, 3) = ss.at(3, 1) = s.at(5);
            ss.at(2, 3) = ss.at(3, 2) = s.at(4);
        } else if ( mode == principal_deviatoricstress ) {
            help = ( s.at(1) + s.at(2) + s.at(3) ) / 3.0;
            ss.at(1, 1) = s.at(1) - help;
            ss.at(2, 2) = s.at(2) - help;
            ss.at(3, 3) = s.at(3) - help;
            ss.at(1, 2) = ss.at(2, 1) = s.at(6);
            ss.at(1, 3) = ss.at(3, 1) = s.at(5);
            ss.at(2, 3) = ss.at(3, 2) = s.at(4);
        } else if ( mode == principal_strain ) {
            ss.at(1, 1) = s.at(1);
            ss.at(2, 2) = s.at(2);
            ss.at(3, 3) = s.at(3);
            ss.at(1, 2) = ss.at(2, 1) = 0.5 * s.at(6);
            ss.at(1, 3) = ss.at(3, 1) = 0.5 * s.at(5);
            ss.at(2, 3) = ss.at(3, 2) = 0.5 * s.at(4);
        } else {
            OOFEM_SERROR("not supported");
        }
    }

#if 0
    ss.Jacobi(& answer, & dir, & i);
#else
    ss.jaco_(answer, dir, 10);
#endif
    // sort results
    nval = 2;
    if ( size == 6 ) {
        nval = 3;
    }

    for ( int ii = 1; ii < nval; ii++ ) {
        for ( int jj = 1; jj < nval; jj++ ) {
            if ( answer.at(jj + 1) > answer.at(jj) ) {
                // swap eigen values and eigen vectors
                swap = answer.at(jj + 1);
                answer.at(jj + 1) = answer.at(jj);
                answer.at(jj) = swap;
                for ( int kk = 1; kk <= nval; kk++ ) {
                    swap = dir.at(kk, jj + 1);
                    dir.at(kk, jj + 1) = dir.at(kk, jj);
                    dir.at(kk, jj) = swap;
                }
            }
        }
    }
}



void
StructuralMaterial :: applyDeviatoricElasticCompliance(FloatArray &strain, const FloatArray &stress, double EModulus, double nu)
{
    applyDeviatoricElasticCompliance( strain, stress, EModulus / 2. / ( 1. + nu ) );
}

void
StructuralMaterial :: applyDeviatoricElasticCompliance(FloatArray &strain, const FloatArray &stress, double GModulus)
{
    strain.resize(6);
    strain[0] = 1. / ( 2. * GModulus ) * stress [ 0 ];
    strain[1] = 1. / ( 2. * GModulus ) * stress [ 1 ];
    strain[2] = 1. / ( 2. * GModulus ) * stress [ 2 ];
    strain[3] = 1. / GModulus * stress [ 3 ];
    strain[4] = 1. / GModulus * stress [ 4 ];
    strain[5] = 1. / GModulus * stress [ 5 ];
}


void
StructuralMaterial :: applyDeviatoricElasticStiffness(FloatArray &stress, const FloatArray &strain, double EModulus, double nu)
{
    applyDeviatoricElasticStiffness( stress, strain, EModulus / ( 2. * ( 1. + nu ) ) );
}

void
StructuralMaterial :: applyDeviatoricElasticStiffness(FloatArray &stress, const FloatArray &strain, double GModulus)
{
    stress.resize(6);
    stress[0] = 2. * GModulus * strain [ 0 ];
    stress[1] = 2. * GModulus * strain [ 1 ];
    stress[2] = 2. * GModulus * strain [ 2 ];
    stress[3] = GModulus * strain [ 3 ];
    stress[4] = GModulus * strain [ 4 ];
    stress[5] = GModulus * strain [ 5 ];
}

void
StructuralMaterial :: applyElasticStiffness(FloatArray &stress, const FloatArray &strain, double EModulus, double nu)
{
    double factor = EModulus / ( ( 1. + nu ) * ( 1. - 2. * nu ) );
    
    stress.resize(6);
    stress[0] = factor * ( ( 1. - nu ) * strain [ 0 ] + nu * strain [ 1 ] + nu * strain [ 2 ] );
    stress[1] = factor * ( nu * strain [ 0 ] + ( 1. - nu ) * strain [ 1 ] + nu * strain [ 2 ] );
    stress[2] = factor * ( nu * strain [ 0 ] + nu * strain [ 1 ] + ( 1. - nu ) * strain [ 2 ] );
    stress[3] = factor * ( ( ( 1. - 2. * nu ) / 2. ) * strain [ 3 ] );
    stress[4] = factor * ( ( ( 1. - 2. * nu ) / 2. ) * strain [ 4 ] );
    stress[5] = factor * ( ( ( 1. - 2. * nu ) / 2. ) * strain [ 5 ] );
}

void
StructuralMaterial :: applyElasticCompliance(FloatArray &strain, const FloatArray &stress, double EModulus, double nu)
{
    strain.resize(6);
    strain[0] = ( stress [ 0 ] - nu * stress [ 1 ] - nu * stress [ 2 ] ) / EModulus;
    strain[1] = ( -nu * stress [ 0 ] + stress [ 1 ] - nu * stress [ 2 ] ) / EModulus;
    strain[2] = ( -nu * stress [ 0 ] - nu * stress [ 1 ] + stress [ 2 ] ) / EModulus;
    strain[3] = ( 2. * ( 1. + nu ) * stress [ 3 ] ) / EModulus;
    strain[4] = ( 2. * ( 1. + nu ) * stress [ 4 ] ) / EModulus;
    strain[5] = ( 2. * ( 1. + nu ) * stress [ 5 ] ) / EModulus;
}



double
StructuralMaterial :: computeVonMisesStress(const FloatArray *currentStress)
{
    double J2;
    double v1, v2, v3;

    if ( currentStress == NULL ) {
        return 0.0;
    }

    if ( currentStress->giveSize() == 3 ) {
        // Plane stress

        return sqrt( currentStress->at(1) * currentStress->at(1) + currentStress->at(2) * currentStress->at(2)
                     - currentStress->at(1) * currentStress->at(2) + 3 * currentStress->at(3) * currentStress->at(3) );
    } else if ( currentStress->giveSize() == 4 ) {
        // Plane strain
        v1 = ( ( currentStress->at(1) - currentStress->at(2) ) * ( currentStress->at(1) - currentStress->at(2) ) );
        v2 = ( ( currentStress->at(2) - currentStress->at(3) ) * ( currentStress->at(2) - currentStress->at(3) ) );
        v3 = ( ( currentStress->at(3) - currentStress->at(1) ) * ( currentStress->at(3) - currentStress->at(1) ) );

        J2 = ( 1. / 6. ) * ( v1 + v2 + v3 ) + currentStress->at(4) * currentStress->at(4);

        return sqrt(3 * J2);
    } else if ( currentStress->giveSize() == 6 ) {
        // 3D
        v1 = ( ( currentStress->at(1) - currentStress->at(2) ) * ( currentStress->at(1) - currentStress->at(2) ) );
        v2 = ( ( currentStress->at(2) - currentStress->at(3) ) * ( currentStress->at(2) - currentStress->at(3) ) );
        v3 = ( ( currentStress->at(3) - currentStress->at(1) ) * ( currentStress->at(3) - currentStress->at(1) ) );

        J2 = ( 1. / 6. ) * ( v1 + v2 + v3 ) + currentStress->at(4) * currentStress->at(4) +
             currentStress->at(5) * currentStress->at(5) + currentStress->at(6) * currentStress->at(6);

        return sqrt(3 * J2);
    } else {
        return 0.0;
    }
}


void
StructuralMaterial :: giveStrainVectorTranformationMtrx(FloatMatrix &answer,
                                                        const FloatMatrix &base,
                                                        bool transpose)
//
// returns transformation matrix for 3d - strains to another system of axes,
// given by base.
// In base (FloatMatrix[3,3]) there are on each column stored vectors of
// coordinate system to which we do transformation.
//
// If transpose == 1 we transpose base matrix before transforming
//
{
    FloatMatrix t;
    answer.resize(6, 6);
    answer.zero();

    if ( transpose ) {
        t.beTranspositionOf(base);
    } else {
        t = base;
    }

    answer.at(1, 1) = t.at(1, 1) * t.at(1, 1);
    answer.at(1, 2) = t.at(2, 1) * t.at(2, 1);
    answer.at(1, 3) = t.at(3, 1) * t.at(3, 1);
    answer.at(1, 4) = t.at(2, 1) * t.at(3, 1);
    answer.at(1, 5) = t.at(1, 1) * t.at(3, 1);
    answer.at(1, 6) = t.at(1, 1) * t.at(2, 1);

    answer.at(2, 1) = t.at(1, 2) * t.at(1, 2);
    answer.at(2, 2) = t.at(2, 2) * t.at(2, 2);
    answer.at(2, 3) = t.at(3, 2) * t.at(3, 2);
    answer.at(2, 4) = t.at(2, 2) * t.at(3, 2);
    answer.at(2, 5) = t.at(1, 2) * t.at(3, 2);
    answer.at(2, 6) = t.at(1, 2) * t.at(2, 2);

    answer.at(3, 1) = t.at(1, 3) * t.at(1, 3);
    answer.at(3, 2) = t.at(2, 3) * t.at(2, 3);
    answer.at(3, 3) = t.at(3, 3) * t.at(3, 3);
    answer.at(3, 4) = t.at(2, 3) * t.at(3, 3);
    answer.at(3, 5) = t.at(1, 3) * t.at(3, 3);
    answer.at(3, 6) = t.at(1, 3) * t.at(2, 3);

    answer.at(4, 1) = 2.0 * t.at(1, 2) * t.at(1, 3);
    answer.at(4, 2) = 2.0 * t.at(2, 2) * t.at(2, 3);
    answer.at(4, 3) = 2.0 * t.at(3, 2) * t.at(3, 3);
    answer.at(4, 4) = ( t.at(2, 2) * t.at(3, 3) + t.at(3, 2) * t.at(2, 3) );
    answer.at(4, 5) = ( t.at(1, 2) * t.at(3, 3) + t.at(3, 2) * t.at(1, 3) );
    answer.at(4, 6) = ( t.at(1, 2) * t.at(2, 3) + t.at(2, 2) * t.at(1, 3) );

    answer.at(5, 1) = 2.0 * t.at(1, 1) * t.at(1, 3);
    answer.at(5, 2) = 2.0 * t.at(2, 1) * t.at(2, 3);
    answer.at(5, 3) = 2.0 * t.at(3, 1) * t.at(3, 3);
    answer.at(5, 4) = ( t.at(2, 1) * t.at(3, 3) + t.at(3, 1) * t.at(2, 3) );
    answer.at(5, 5) = ( t.at(1, 1) * t.at(3, 3) + t.at(3, 1) * t.at(1, 3) );
    answer.at(5, 6) = ( t.at(1, 1) * t.at(2, 3) + t.at(2, 1) * t.at(1, 3) );

    answer.at(6, 1) = 2.0 * t.at(1, 1) * t.at(1, 2);
    answer.at(6, 2) = 2.0 * t.at(2, 1) * t.at(2, 2);
    answer.at(6, 3) = 2.0 * t.at(3, 1) * t.at(3, 2);
    answer.at(6, 4) = ( t.at(2, 1) * t.at(3, 2) + t.at(3, 1) * t.at(2, 2) );
    answer.at(6, 5) = ( t.at(1, 1) * t.at(3, 2) + t.at(3, 1) * t.at(1, 2) );
    answer.at(6, 6) = ( t.at(1, 1) * t.at(2, 2) + t.at(2, 1) * t.at(1, 2) );
}


void
StructuralMaterial :: giveStressVectorTranformationMtrx(FloatMatrix &answer,
                                                        const FloatMatrix &base,
                                                        bool transpose)
//
// returns transformation matrix for 3d - stress to another system of axes,
// given by base.
// In base (FloatMatrix[3,3]) there are on each column stored vectors of
// coordinate system to which we do transformation.
//
// If transpose == 1 we transpose base matrix before transforming
//
{
    FloatMatrix t;
    answer.resize(6, 6);
    answer.zero();

    if ( transpose ) {
        t.beTranspositionOf(base);
    } else {
        t = base;
    }

    answer.at(1, 1) = t.at(1, 1) * t.at(1, 1);
    answer.at(1, 2) = t.at(2, 1) * t.at(2, 1);
    answer.at(1, 3) = t.at(3, 1) * t.at(3, 1);
    answer.at(1, 4) = 2.0 * t.at(2, 1) * t.at(3, 1);
    answer.at(1, 5) = 2.0 * t.at(1, 1) * t.at(3, 1);
    answer.at(1, 6) = 2.0 * t.at(1, 1) * t.at(2, 1);

    answer.at(2, 1) = t.at(1, 2) * t.at(1, 2);
    answer.at(2, 2) = t.at(2, 2) * t.at(2, 2);
    answer.at(2, 3) = t.at(3, 2) * t.at(3, 2);
    answer.at(2, 4) = 2.0 * t.at(2, 2) * t.at(3, 2);
    answer.at(2, 5) = 2.0 * t.at(1, 2) * t.at(3, 2);
    answer.at(2, 6) = 2.0 * t.at(1, 2) * t.at(2, 2);

    answer.at(3, 1) = t.at(1, 3) * t.at(1, 3);
    answer.at(3, 2) = t.at(2, 3) * t.at(2, 3);
    answer.at(3, 3) = t.at(3, 3) * t.at(3, 3);
    answer.at(3, 4) = 2.0 * t.at(2, 3) * t.at(3, 3);
    answer.at(3, 5) = 2.0 * t.at(1, 3) * t.at(3, 3);
    answer.at(3, 6) = 2.0 * t.at(1, 3) * t.at(2, 3);

    answer.at(4, 1) = t.at(1, 2) * t.at(1, 3);
    answer.at(4, 2) = t.at(2, 2) * t.at(2, 3);
    answer.at(4, 3) = t.at(3, 2) * t.at(3, 3);
    answer.at(4, 4) = ( t.at(2, 2) * t.at(3, 3) + t.at(3, 2) * t.at(2, 3) );
    answer.at(4, 5) = ( t.at(1, 2) * t.at(3, 3) + t.at(3, 2) * t.at(1, 3) );
    answer.at(4, 6) = ( t.at(1, 2) * t.at(2, 3) + t.at(2, 2) * t.at(1, 3) );

    answer.at(5, 1) = t.at(1, 1) * t.at(1, 3);
    answer.at(5, 2) = t.at(2, 1) * t.at(2, 3);
    answer.at(5, 3) = t.at(3, 1) * t.at(3, 3);
    answer.at(5, 4) = ( t.at(2, 1) * t.at(3, 3) + t.at(3, 1) * t.at(2, 3) );
    answer.at(5, 5) = ( t.at(1, 1) * t.at(3, 3) + t.at(3, 1) * t.at(1, 3) );
    answer.at(5, 6) = ( t.at(1, 1) * t.at(2, 3) + t.at(2, 1) * t.at(1, 3) );

    answer.at(6, 1) = t.at(1, 1) * t.at(1, 2);
    answer.at(6, 2) = t.at(2, 1) * t.at(2, 2);
    answer.at(6, 3) = t.at(3, 1) * t.at(3, 2);
    answer.at(6, 4) = ( t.at(2, 1) * t.at(3, 2) + t.at(3, 1) * t.at(2, 2) );
    answer.at(6, 5) = ( t.at(1, 1) * t.at(3, 2) + t.at(3, 1) * t.at(1, 2) );
    answer.at(6, 6) = ( t.at(1, 1) * t.at(2, 2) + t.at(2, 1) * t.at(1, 2) );
}


void
StructuralMaterial :: givePlaneStressVectorTranformationMtrx(FloatMatrix &answer,
                                                             const FloatMatrix &base,
                                                             bool transpose)
//
// returns transformation matrix for 2d - stress to another system of axes,
// given by base.
// In base (FloatMatrix[2,2]) there are on each column stored vectors of
// coordinate system to which we do transformation.
//
// If transpose == 1 we transpose base matrix before transforming
//
{
    FloatMatrix t;
    answer.resize(3, 3);
    answer.zero();

    if ( transpose ) {
        t.beTranspositionOf(base);
    } else {
        t = base;
    }

    answer.at(1, 1) = t.at(1, 1) * t.at(1, 1);
    answer.at(1, 2) = t.at(2, 1) * t.at(2, 1);
    answer.at(1, 3) = 2.0 * t.at(1, 1) * t.at(2, 1);

    answer.at(2, 1) = t.at(1, 2) * t.at(1, 2);
    answer.at(2, 2) = t.at(2, 2) * t.at(2, 2);
    answer.at(2, 3) = 2.0 * t.at(1, 2) * t.at(2, 2);

    answer.at(3, 1) = t.at(1, 1) * t.at(1, 2);
    answer.at(3, 2) = t.at(2, 1) * t.at(2, 2);
    answer.at(3, 3) = t.at(1, 1) * t.at(2, 2) + t.at(2, 1) * t.at(1, 2);
}




double
StructuralMaterial :: compute_I1_C_from_F(const FloatMatrix &F)
{
#ifdef DEBUG
    if ( F.giveNumberOfRows() != 3 || F.giveNumberOfColumns() != 3 ) {
      OOFEM_ERROR("Inconsistent size of deformation gradient");
    }
#endif
    FloatMatrix C;
    C.beTProductOf(F,F);
    
    return ( C.at(1,1) + C.at(2,2) + C.at(3,3) );
}

double
StructuralMaterial :: compute_I2_C_from_F(const FloatMatrix &F)
{
#ifdef DEBUG
  if ( F.giveNumberOfRows() != 3 || F.giveNumberOfColumns() != 3 ) {
    OOFEM_ERROR("Inconsistent size of deformation gradient");
  }
#endif
  FloatMatrix C, C2;
  C.beTProductOf(F,F);
  C2.beProductOf(C,C);
  double a = C.at(1,1) + C.at(2,2) + C.at(3,3);
  double b = C2.at(1,1) + C2.at(2,2) + C2.at(3,3);
  return ( 0.5 * ( a * a - b ) );
}



double
StructuralMaterial :: compute_I1_C_from_C(const FloatMatrix &C)
{
#ifdef DEBUG
    if ( C.giveNumberOfRows() != 3 || C.giveNumberOfColumns() != 3 ) {
      OOFEM_ERROR("Inconsistent size of deformation gradient");
    }
#endif   
    return ( C.at(1,1) + C.at(2,2) + C.at(3,3) );
}

double
StructuralMaterial :: compute_I2_C_from_C(const FloatMatrix &C)
{
#ifdef DEBUG
  if ( C.giveNumberOfRows() != 3 || C.giveNumberOfColumns() != 3 ) {
    OOFEM_ERROR("Inconsistent size of deformation gradient");
  }
#endif
  FloatMatrix C2;
  C2.beProductOf(C,C);
  double a = C.at(1,1) + C.at(2,2) + C.at(3,3);
  double b = C2.at(1,1) + C2.at(2,2) + C2.at(3,3);
  return ( 0.5 * ( a * a - b ) );
}

  
double
StructuralMaterial :: compute_I3_C_from_F(const FloatMatrix &F)
{
#ifdef DEBUG
  if ( F.giveNumberOfRows() != 3 || F.giveNumberOfColumns() != 3 ) {
    OOFEM_ERROR("Inconsistent size of deformation gradient");
  }
#endif
  double J = F.giveDeterminant();
  return J*J;

}

void
StructuralMaterial :: compute_dI1_C_dF(FloatArray &answer, const FloatMatrix &F)
{
  answer.beVectorForm(F);
  answer.times(2);
}

void
StructuralMaterial :: compute_dI2_C_dF(FloatArray &answer, const FloatMatrix &F)
{
  double I1;
  FloatMatrix C, FC, mAnswer;
  C.beTProductOf(F,F);
  I1 = C.at(1,1) + C.at(2,2) + C.at(3,3); 
  FC.beProductOf(F,C);
  FC.times(2);
  mAnswer = F;
  mAnswer.times(I1);
  mAnswer.subtract(FC);
  answer.beVectorForm(mAnswer);
}

  

void
StructuralMaterial :: compute_dI3_C_dF(FloatArray &answer, const FloatMatrix &F)
{}


void
StructuralMaterial :: compute_dJ_dF(FloatArray &answer, const FloatMatrix &F)
{

  double J;
  FloatMatrix invF, invFt;
  
  invF.beInverseOf(F);
  J = F.giveDeterminant();
  invFt.beTranspositionOf(invF);
  answer.beVectorForm(invFt);
  answer.times(J);
}

  

void
StructuralMaterial :: compute_d2I1_C_dF2(FloatMatrix &answer, const FloatMatrix &F)
{

    answer.resize(9, 9);
    answer.zero();

    FloatMatrix I(3, 3);
    I.beUnitMatrix();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) += 2. *  I.at( i, k ) * I.at( j, l );
	  }
	}
      }
    }     
}


void
StructuralMaterial :: computeNumerical_d2I1_Cdev_dF2(FloatMatrix &stiff1, FloatMatrix &stiff2, const FloatMatrix &F)
{

    
    FloatArray dI1dF, dI2dF;
    
    compute_dI1_Cdev_dF(dI1dF, F);
    compute_dI2_Cdev_dF(dI2dF, F);
    


    double pert = 1.e-8;  
    FloatArray pdI1dF, pdI2dF;
    FloatMatrix pF;
    stiff1.resize(9,9);
    stiff2.resize(9,9);
    stiff1.zero();
    stiff2.zero();
      
    pF = F;
    pF.at(1,1) += pert;
    compute_dI1_Cdev_dF(pdI1dF, pF);
    compute_dI2_Cdev_dF(pdI2dF, pF);

    for(int i = 1; i <= 9; i++) {
      stiff1.at(i,1) = pdI1dF.at(i) - dI1dF.at(i);
      stiff2.at(i,1) = pdI2dF.at(i) - dI2dF.at(i);    
    }


    pF = F;
    pF.at(2,2) += pert;
    compute_dI1_Cdev_dF(pdI1dF, pF);
    compute_dI2_Cdev_dF(pdI2dF, pF);

    for(int i = 1; i <= 9; i++) {
      stiff1.at(i,2) = pdI1dF.at(i) - dI1dF.at(i);
      stiff2.at(i,2) = pdI2dF.at(i) - dI2dF.at(i);    
    }


    pF = F;
    pF.at(3,3) += pert;
    compute_dI1_Cdev_dF(pdI1dF, pF);
    compute_dI2_Cdev_dF(pdI2dF, pF);

    for(int i = 1; i <= 9; i++) {
      stiff1.at(i,3) = pdI1dF.at(i) - dI1dF.at(i);
      stiff2.at(i,3) = pdI2dF.at(i) - dI2dF.at(i);    
    }


    pF = F;
    pF.at(2,3) += pert;
    compute_dI1_Cdev_dF(pdI1dF, pF);
    compute_dI2_Cdev_dF(pdI2dF, pF);

    for(int i = 1; i <= 9; i++) {
      stiff1.at(i,4) = pdI1dF.at(i) - dI1dF.at(i);
      stiff2.at(i,4) = pdI2dF.at(i) - dI2dF.at(i);    
    }

    pF = F;
    pF.at(1,3) += pert;
    compute_dI1_Cdev_dF(pdI1dF, pF);
    compute_dI2_Cdev_dF(pdI2dF, pF);

    for(int i = 1; i <= 9; i++) {
      stiff1.at(i,5) = pdI1dF.at(i) - dI1dF.at(i);
      stiff2.at(i,5) = pdI2dF.at(i) - dI2dF.at(i);    
    }

    pF = F;
    pF.at(1,2) += pert;
    compute_dI1_Cdev_dF(pdI1dF, pF);
    compute_dI2_Cdev_dF(pdI2dF, pF);

    for(int i = 1; i <= 9; i++) {
      stiff1.at(i,6) = pdI1dF.at(i) - dI1dF.at(i);
      stiff2.at(i,6) = pdI2dF.at(i) - dI2dF.at(i);    
    }

    pF = F;
    pF.at(3,2) += pert;
    compute_dI1_Cdev_dF(pdI1dF, pF);
    compute_dI2_Cdev_dF(pdI2dF, pF);

    for(int i = 1; i <= 9; i++) {
      stiff1.at(i,7) = pdI1dF.at(i) - dI1dF.at(i);
      stiff2.at(i,7) = pdI2dF.at(i) - dI2dF.at(i);    
    }


    pF = F;
    pF.at(3,1) += pert;
    compute_dI1_Cdev_dF(pdI1dF, pF);
    compute_dI2_Cdev_dF(pdI2dF, pF);

    for(int i = 1; i <= 9; i++) {
      stiff1.at(i,8) = pdI1dF.at(i) - dI1dF.at(i);
      stiff2.at(i,8) = pdI2dF.at(i) - dI2dF.at(i);    
    }

    pF = F;
    pF.at(2,1) += pert;
    compute_dI1_Cdev_dF(pdI1dF, pF);
    compute_dI2_Cdev_dF(pdI2dF, pF);

    for(int i = 1; i <= 9; i++) {
      stiff1.at(i,9) = pdI1dF.at(i) - dI1dF.at(i);
      stiff2.at(i,9) = pdI2dF.at(i) - dI2dF.at(i);    
    }    
    

  stiff1.times(1./pert);
  stiff2.times(1./pert);
}


  
 
void
StructuralMaterial :: compute_d2I2_C_dF2(FloatMatrix &answer, const FloatMatrix &F)
{
    answer.resize(9, 9);
    answer.zero();

    double I1;
    FloatMatrix C, B, I(3, 3);
    I.beUnitMatrix();
    C.beTProductOf(F,F);
    C.beProductTOf(F,F);
    I1 = C.at(1,1) + C.at(2,2) + C.at(3,3); 
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) += 2. * F.at( i, j ) * F.at( k, l ) - 2. * F.at( i, l ) * F.at( k, j ) + I1 * I.at( i, k ) * I.at( j, l ) - 2. * C.at( l, j ) * I.at( i, k ) - 2. * B.at( i, k ) * I.at( j, l );
	  }
	}
      }
    }  

}




void
StructuralMaterial :: compute_d2I1_C_dF2_and_d2I2_C_dF2(FloatMatrix &d2I1dF2, FloatMatrix &d2I2dF2, const FloatMatrix &F)
{

    d2I1dF2.resize(9, 9);
    d2I1dF2.zero();

    d2I2dF2.resize(9, 9);
    d2I2dF2.zero();

    double I1;
    FloatMatrix C, B, I(3, 3);
    I.beUnitMatrix();
    C.beTProductOf(F,F);
    C.beProductTOf(F,F);
    I1 = C.at(1,1) + C.at(2,2) + C.at(3,3); 

    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    d2I1dF2.at( giveVI(i, j), giveVI(k, l) ) += 2. * I.at( i, k ) * I.at( j, l );
	    d2I2dF2.at( giveVI(i, j), giveVI(k, l) ) += 2. * F.at( i, j )* F.at( k, l ) - 2. * F.at( i, l )* F.at( k, j ) + I1 * I.at( i, k ) * I.at( j, l ) - 2. * C.at( l, j ) * I.at( i, k ) - 2. * B.at( i, k ) * I.at( j, l );
	  }
	}
      }
    }  

}



  
void
StructuralMaterial :: compute_d2I3_C_dF2(FloatMatrix &answer, const FloatMatrix &F)
{}


void
StructuralMaterial :: compute_d2J_dF2(FloatMatrix &answer, const FloatMatrix &F)
{

    double J;
    FloatMatrix invF;
    
    invF.beInverseOf(F);
    J = F.giveDeterminant();
    
  
    answer.resize(9, 9);
    answer.zero();

   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) += invF.at( j, i ) * invF.at( l, k ) - invF.at( j, k ) * invF.at( l, i );
	  }
	}
      }
    }
    answer.times(J);

}


void
StructuralMaterial :: compute_d2lnJ_dF2(FloatMatrix &answer, const FloatMatrix &F)
{

    FloatMatrix invF;    
    invF.beInverseOf(F);
    
    answer.resize(9, 9);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) = -invF.at( j, k ) * invF.at( l, i );
	  }
	}
      }
    }
    
}
  



 

double
StructuralMaterial :: compute_I1_Cdev_from_F(const FloatMatrix &F)
{
  double I1 = this->compute_I1_C_from_F(F);
  double J = F.giveDeterminant();
  return pow(J, -2./3.) * I1;
}

double
StructuralMaterial :: compute_I2_Cdev_from_F(const FloatMatrix &F)
{
    double I2 = this->compute_I2_C_from_F(F);
    double J = F.giveDeterminant();
    return pow(J, -4./3.) * I2;

}

void
StructuralMaterial :: compute_dI1_Cdev_dF(FloatArray &answer, const FloatMatrix &F)
{

  double I1 = this->compute_I1_C_from_F(F);
  double J_23 = pow(F.giveDeterminant(), -2./3.);
  FloatMatrix invF, invFt;
  invF.beInverseOf(F);
  invFt.beTranspositionOf(invF);
  invFt.times(2./3.*I1);

  FloatMatrix mAnswer;
  mAnswer = F;
  mAnswer.times(2.);
  mAnswer.subtract(invFt);
  mAnswer.times(J_23);
  answer.beVectorForm(mAnswer);
  
}

void
StructuralMaterial :: compute_dI2_Cdev_dF(FloatArray &answer, const FloatMatrix &F)
{
  
    double I1 = this->compute_I1_C_from_F(F);
    double I2 = this->compute_I2_C_from_F(F);
    double J_43 = pow(F.giveDeterminant(), -4./3.);
  
    FloatMatrix invF, invFt, C, FC;
    invF.beInverseOf(F);
    invFt.beTranspositionOf(invF);
    invFt.times(4./3.*I2);

    C.beTProductOf(F,F);
    FC.beProductOf(F,C);
    FC.times(2.);


    FloatMatrix mAnswer;
    mAnswer = F;
    mAnswer.times(2.*I1);
    mAnswer.subtract(invFt);
    mAnswer.subtract(FC);
    mAnswer.times(J_43);
    answer.beVectorForm(mAnswer);

}







void
StructuralMaterial :: compute_d2I1_Cdev_dF2(FloatMatrix &answer, const FloatMatrix &F)
{


    answer.resize(9, 9);
    answer.zero();

    double I1;
    FloatMatrix C, invF, I(3, 3);
    double J_23 = pow(F.giveDeterminant(), -2./3.);
    C.beTProductOf(F,F);
    C.beProductTOf(F,F);
    invF.beInverseOf(F);
    I.beUnitMatrix();
    I1 = C.at(1,1) + C.at(2,2) + C.at(3,3); 

    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) += 3. * I.at( i, k ) * I.at( j, l ) + I1 * invF.at( j, k )* invF.at( l, i ) - 2./3. * I1 * invF.at( j, i )* F.at( l, k )- 2. * invF.at( l, k )* F.at( i, j )- 2. * invF.at( j, i )* F.at( k, l );
	  }
	}
      }
    }  

    answer.times(2./3.*J_23);
  

}

void
StructuralMaterial :: compute_d2I2_Cdev_dF2(FloatMatrix &answer, const FloatMatrix &F)
{

    answer.resize(9, 9);
    answer.zero();

    double I1, I2;
    FloatMatrix FC, C, B, invF, I(3, 3);
    double J_43 = pow(F.giveDeterminant(), -4./3.);
    C.beTProductOf(F,F);
    B.beProductTOf(F,F);
    
    invF.beInverseOf(F);
    I.beUnitMatrix();
    I1 = this->compute_I1_C_from_C(C);
    I2 = this->compute_I2_C_from_C(C);
    FC.beProductOf(F,C);

    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) = I1 * I.at( i, k ) * I.at( j, l ) + 2. * F.at( i, j ) * F.at( k, l ) - 4./3. * I1 * F.at( i, j )  * invF.at( l, k ) + 8./9. * I2 * invF.at( j, i )  * invF.at( l, k ) - 4./3. * I1 * invF.at( j, i )  * F.at( k, l ) + 4. / 3. * FC.at(k,l) *  invF.at(j,i) + 2./3. * I2 * invF.at( j, k )  * invF.at( l, i ) + 4./3. * FC.at( i, j ) * invF.at( l, k ) - C.at( l, j ) * I.at(i, k) - F.at( i, l ) * F.at( k, j ) - B.at( i, k ) * I.at(l, j);

	  }
	}
      }
    }  

    answer.times( 2. * J_43 );
}


void
StructuralMaterial :: compute_dInvFt_dF(FloatMatrix &answer, const FloatMatrix &invF)
{
  
    answer.resize(9, 9);
    answer.zero();
   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) = - invF.at( j, k ) * invF.at( l, i );
	  }
	}
      }
    }  
}


void 
StructuralMaterial :: compute_d2I1_Cdev_dF2_and_d2I2_Cdev_dF2(FloatMatrix &d2I1dF2, FloatMatrix &d2I2dF2, const FloatMatrix &F)
      

{  
    d2I1dF2.resize(9, 9);
    d2I1dF2.zero();
    
    d2I2dF2.resize(9, 9);
    d2I2dF2.zero();

       
    double I1, I2, J;
    FloatMatrix C, B, FC, invF, I(3, 3);

    J = F.giveDeterminant();
    double J_23 = pow(J, -2./3.);
    double J_43 = pow(J, -4./3.);
    
    
    C.beTProductOf(F,F);
    B.beProductTOf(F,F);
    invF.beInverseOf(F);
    I.beUnitMatrix();
    I1 = this->compute_I1_C_from_C(C);
    I2 = this->compute_I2_C_from_C(C);
    FC.beProductOf(F,C);


    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    d2I1dF2.at( giveVI(i, j), giveVI(k, l) ) = 3. * I.at( i, k ) * I.at( j, l ) + I1 * invF.at( j, k )* invF.at( l, i ) + 2./3. * I1 * invF.at( j, i )* invF.at( l, k )- 2. * invF.at( l, k )* F.at( i, j ) - 2. * invF.at( j, i )* F.at( k, l );
	    d2I2dF2.at( giveVI(i, j), giveVI(k, l) ) = I1 * I.at( i, k ) * I.at( j, l ) + 2. * F.at( i, j ) * F.at( k, l ) - 4./3. * I1 * F.at( i, j )  * invF.at( l, k ) + 8./9. * I2 * invF.at( j, i )  * invF.at( l, k ) - 4./3. * I1 * invF.at( j, i )  * F.at( k, l ) + 4. / 3. * FC.at(k,l) *  invF.at(j,i) + 2./3. * I2 * invF.at( j, k )  * invF.at( l, i ) + 4./3. * FC.at( i, j ) * invF.at( l, k ) - C.at( l, j ) * I.at(i, k) - F.at( i, l ) * F.at( k, j ) - B.at( i, k ) * I.at(l, j);
	  }
	}
      }
    }  
    
    d2I1dF2.times( 2./3. * J_23 );
    d2I2dF2.times( 2. * J_43 );
}



void
StructuralMaterial :: compute_dyadic_product(FloatMatrix &answer, const FloatMatrix &a, const FloatMatrix &b)
{

    answer.resize(9, 9);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) = a.at(i,j) * b.at(k,l);
	  }
	}
      }
    }
}


void
StructuralMaterial :: compute_dyadic_product(FloatMatrix &answer, const FloatArray &a, const FloatArray &b)
{

    answer.resize(9, 9);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) = a.at(giveVI(i, j)) * b.at(giveVI(k, l));
	  }
	}
      }
    }
}





void
StructuralMaterial :: compute_dyadic_product_reduced(FloatMatrix &answer, const FloatMatrix &a, const FloatMatrix &b)
{

    answer.resize(6, 6);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    if(i <= j && k <= l){
	      answer.at( giveSymVI(i, j), giveSymVI(k, l) ) = a.at(i,j) * b.at(k,l);
	    }
	  }
	}
      }
    }
}


void
StructuralMaterial :: compute_dyadic_product_reduced(FloatMatrix &answer, const FloatArray &a, const FloatArray &b)
{

    answer.resize(6, 6);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    if(i <= j && k <= l){
	      answer.at( giveSymVI(i, j), giveSymVI(k, l) ) = a.at(giveSymVI(i, j)) * b.at(giveSymVI(k, l));
	    }
	  }
	}
      }
    }
}





void
StructuralMaterial :: compute_sym_dyadic_product(FloatMatrix &answer, const FloatMatrix &a, const FloatMatrix &b)
{

    answer.resize(9, 9);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) = 1./2. * ( a.at(i,k) * b.at(l,j) + a.at(i,l) * b.at(k,j) );
	  }
	}
      }
    }
}


void
StructuralMaterial :: compute_sym_dyadic_product_reduced(FloatMatrix &answer, const FloatMatrix &a, const FloatMatrix &b)
{

    answer.resize(6, 6);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    if(i <= j && k <= l){
	      answer.at( giveVI(i, j), giveVI(k, l) ) = 1./2. * ( a.at(i,k) * b.at(l,j) + a.at(i,l) * b.at(k,j) );
	    }
	  }
	}
      }
    }
}




void
StructuralMaterial :: compute_lower_dyadic_product(FloatMatrix &answer, const FloatMatrix &a, const FloatMatrix &b)
{

    answer.resize(9, 9);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) = a.at(i,k) * b.at(j,l);
	  }
	}
      }
    }
}



void
StructuralMaterial :: compute_upper_dyadic_product(FloatMatrix &answer, const FloatMatrix &a, const FloatMatrix &b)
{

    answer.resize(9, 9);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, j), giveVI(k, l) ) = a.at(i,l) * b.at(j,k);
	  }
	}
      }
    }
}


void
StructuralMaterial :: compute_3order_dyadic_product(FloatMatrix &answer, const FloatArray &aa, const FloatMatrix &mb)
{
    answer.resize(9, 3);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    answer.at( giveVI(i, k), l ) = aa.at(i) * mb.at( k, l );
	  }
	}
    }
}

void
StructuralMaterial :: compute_3order_dyadic_product(FloatMatrix &answer, const FloatMatrix &ma, const FloatArray &ab)
{
    answer.resize(9, 3);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  answer.at( giveVI(i, j), k ) = ma.at(i, j) * ab.at(k);
	}
      }
    }
    
}


void
StructuralMaterial :: compute_3order_lower_dyadic_product(FloatMatrix &answer, const FloatMatrix &ma, const FloatArray &ab)
{
    answer.resize(9, 3);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  answer.at( giveVI(i, j), k ) = ma.at(i, k) * ab.at(j);
	}
      }
    }  
}



void
StructuralMaterial :: compute_dot_product(FloatMatrix &answer, const FloatMatrix &a, const FloatArray &b, int index)
{

    answer.resize(9, 3);
    answer.zero();

    if(a.giveNumberOfRows() != 9 || a.giveNumberOfColumns() != 9) {
      OOFEM_ERROR("This method works only for 9x9 matrices")
    }
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int l = 1; l <= 3; l++ ) {
	    if(index == 1) {
	      answer.at( giveVI(i, j), k ) += a.at(giveVI(i, j),giveVI(k, l)) * b.at(i);
	    } else if(index == 2) {
	      answer.at( giveVI(i, j), k ) += a.at(giveVI(i, j),giveVI(k, l)) * b.at(j);
	    } else if(index == 3) {
	      answer.at( giveVI(i, j), k ) += a.at(giveVI(i, j),giveVI(k, l)) * b.at(k);
	    } else if(index == 4) {
	      answer.at( giveVI(i, j), k ) += a.at(giveVI(i, j),giveVI(k, l)) * b.at(l);
	    } else {
	      OOFEM_ERROR("Index out of scope")
	    }
	  }
	}
      }
    }

}

void
StructuralMaterial :: give_3order_tensor_39(FloatMatrix &answer, const FloatMatrix &source)
{
 
    if(source.giveNumberOfRows() != 9 || source.giveNumberOfColumns() != 3) {
      OOFEM_ERROR("3rd order tensor expected, i.e., 9x3 matrix");
    }
    answer.resize(3,9);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  answer.at( i, giveVI(j, k) ) = source.at(giveVI(i, j), k);
	}
      }
    }
}


void
StructuralMaterial :: give_3order_tensor_93(FloatMatrix &answer, const FloatMatrix &source)
{
 
    if(source.giveNumberOfRows() != 3 || source.giveNumberOfColumns() != 9) {
      OOFEM_ERROR("3rd order tensor expected, i.e., 3x9 matrix");
    }
    answer.resize(9,3);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  answer.at(giveVI(i, j), k) = source.at( i, giveVI(j, k) );
	}
      }
    }
}

void
StructuralMaterial :: give_3order_tensor_switch(FloatMatrix &answer, const FloatMatrix &source, int ia, int ib)
{
 
    if(source.giveNumberOfRows() != 9 || source.giveNumberOfColumns() != 3) {
      OOFEM_ERROR("3rd order tensor expected, i.e., 9x3 matrix");
    }
    answer.resize(9,3);
    answer.zero();
    
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  if(ia == 1 && ib == 2) {
	    answer.at( giveVI(i, j), k ) = source.at(giveVI(j, i), k);
	  } else if(ia == 1 && ib == 3) {
	    answer.at( giveVI(i, j), k ) = source.at(giveVI(k, j), i);
	  } else if(ia == 2 && ib == 3) {
	    answer.at( giveVI(i, j), k ) = source.at(giveVI(i, k), j);
	  }
	}
      }
    }
}



void
StructuralMaterial :: compute_2order_tensor_cross_product(FloatMatrix &answer, const FloatMatrix &a, const FloatMatrix &b)
{

    answer.resize(3, 3);
    answer.zero();

    FloatMatrix lc;
    lc.beLeviCivitaTensor();
   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int m = 1; m <= 3; m++ ) {
	    for ( int l = 1; l <= 3; l++ ) {
	      for ( int n = 1; n <= 3; n++ ) {
		answer.at( i, j ) += lc.at( giveVI( i, k ), l ) * lc.at( giveVI( j, m ), n ) * a.at( k, m ) * b.at( l, n );
	      }
	    }
	  }
	}
      }
    }
}







void
StructuralMaterial :: compute_2order_tensor_cross_product(FloatArray &answer, const FloatArray &a, const FloatArray &b)
{

    answer.resize(9);
    answer.zero();


    FloatMatrix lc;
    lc.beLeviCivitaTensor();
   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int m = 1; m <= 3; m++ ) {
	    for ( int l = 1; l <= 3; l++ ) {
	      for ( int n = 1; n <= 3; n++ ) {
		answer.at( giveVI( i, j ) ) += lc.at( giveVI( i, k ), l ) * lc.at( giveVI( j, m ), n ) * a.at( giveVI(k, m) ) * b.at( giveVI(l, n) );
	      }
	    }
	  }
	}
      }
    }
}


void
StructuralMaterial :: compute_2order_tensor_cross_product(FloatMatrix &answer, const FloatArray &a, const FloatArray &b)
{

    answer.resize(3,3);
    answer.zero();


    FloatMatrix lc;
    lc.beLeviCivitaTensor();
   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int k = 1; k <= 3; k++ ) {
	  for ( int m = 1; m <= 3; m++ ) {
	    for ( int l = 1; l <= 3; l++ ) {
	      for ( int n = 1; n <= 3; n++ ) {
		answer.at( i, j ) += lc.at( giveVI( i, k ), l ) * lc.at( giveVI( j, m ), n ) * a.at( giveVI(k, m) ) * b.at( giveVI(l, n) );
	      }
	    }
	  }
	}
      }
    }
}



void
StructuralMaterial :: compute_3order_tensor_cross_product_32(FloatMatrix &answer, const FloatMatrix &ma, const FloatMatrix &mb)
{

    answer.resize(9,3);
    answer.zero();


    FloatMatrix lc;
    lc.beLeviCivitaTensor();
   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int m = 1; m <= 3; m++ ) {
	for ( int n = 1; n <= 3; n++ ) {
	  for ( int k = 1; k <= 3; k++ ) {
	    for ( int l = 1; l <= 3; l++ ) {
	      for ( int p = 1; p <= 3; p++ ) {
		for ( int q = 1; q <= 3; q++ ) {
		  answer.at( giveVI( i, m ), n ) += lc.at( giveVI( m, k ), p ) * lc.at( giveVI( n, l ), q ) * ma.at( giveVI(k, l), i ) * mb.at(p, q);
		}
	      }
	    }
	  }
	}
      }
    }
}

void
StructuralMaterial :: compute_3order_tensor_cross_product_23(FloatMatrix &answer, const FloatMatrix &ma, const FloatMatrix &mb)
{

    answer.resize(9,3);
    answer.zero();


    FloatMatrix lc;
    lc.beLeviCivitaTensor();
   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int m = 1; m <= 3; m++ ) {
	for ( int n = 1; n <= 3; n++ ) {
	  for ( int k = 1; k <= 3; k++ ) {
	    for ( int l = 1; l <= 3; l++ ) {
	      for ( int p = 1; p <= 3; p++ ) {
		for ( int q = 1; q <= 3; q++ ) {
		  answer.at( giveVI( i, m ), n ) += lc.at( giveVI( m, k ), p ) * lc.at( giveVI( n, l ), q ) * ma.at(k, l) * mb.at( giveVI(p, q), i );
		}
	      }
	    }
	  }
	}
      }
    }
}


void
StructuralMaterial :: compute_4order_tensor_cross_product(FloatMatrix &answer, const FloatArray &ma, const FloatMatrix &mb)
{

    answer.resize(9,9);
    answer.zero();


    FloatMatrix lc;
    lc.beLeviCivitaTensor();
   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int l = 1; l <= 3; l++ ) {
	  for ( int n = 1; n <= 3; n++ ) {
	    for ( int p = 1; p <= 3; p++ ) {
	      for ( int q = 1; q <= 3; q++ ) {
		for ( int a = 1; a <= 3; a++ ) {
		  for ( int b = 1; b <= 3; b++ ) {
		    answer.at( giveVI( i, j ), giveVI( a, b ) ) += lc.at( giveVI( i, l ), p ) * lc.at( giveVI( j, n ), q ) * ma.at( giveVI(l, n) ) * mb.at( giveVI(p, q), giveVI(a, b) );
		  }
		}
	      }
	    }
	  }
	}
      }
    }
}



void
StructuralMaterial :: compute_4order_tensor_cross_product(FloatMatrix &answer, const FloatMatrix &ma, const FloatMatrix &mb)
{

    answer.resize(9,9);
    answer.zero();


    FloatMatrix lc;
    lc.beLeviCivitaTensor();
   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int l = 1; l <= 3; l++ ) {
	  for ( int n = 1; n <= 3; n++ ) {
	    for ( int p = 1; p <= 3; p++ ) {
	      for ( int q = 1; q <= 3; q++ ) {
		for ( int a = 1; a <= 3; a++ ) {
		  for ( int b = 1; b <= 3; b++ ) {
		    answer.at( giveVI( i, j ), giveVI( a, b ) ) += lc.at( giveVI( i, l ), p ) * lc.at( giveVI( j, n ), q ) * ma.at( l, n ) * mb.at( giveVI(p, q), giveVI(a, b) );
		  }
		}
	      }
	    }
	  }
	}
      }
    }
}

 


void
StructuralMaterial :: compute_tensor_cross_product_tensor(FloatMatrix &answer, const FloatMatrix &a)
{

    answer.resize(9, 9);
    answer.zero();

    FloatMatrix lc;
    lc.beLeviCivitaTensor();
   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int r = 1; r <= 3; r++ ) {
	  for ( int s = 1; s <= 3; s++ ) {
	    for ( int k = 1; k <= 3; k++ ) {
	      for ( int m = 1; m <= 3; m++ ) {
		answer.at( giveVI(i, j), giveVI(r, s) ) += lc.at( giveVI( i, r ), k ) * lc.at( giveVI( j, s ), m ) * a.at( k, m );
	      }
	    }
	  }
	}
      }
    }
}



void
StructuralMaterial :: compute_tensor_cross_product_tensor(FloatMatrix &answer, const FloatArray &a)
{

    answer.resize(9, 9);
    answer.zero();

    FloatMatrix lc;
    lc.beLeviCivitaTensor();
   
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	for ( int r = 1; r <= 3; r++ ) {
	  for ( int s = 1; s <= 3; s++ ) {
	    for ( int k = 1; k <= 3; k++ ) {
	      for ( int m = 1; m <= 3; m++ ) {
		answer.at( giveVI(i, j), giveVI(r, s) ) += lc.at( giveVI( i, r ), k ) * lc.at( giveVI( j, s ), m ) * a.at( giveVI(k, m) );
	      }
	    }
	  }
	}
      }
    }
}


void
StructuralMaterial :: compute_dCm_dC(FloatMatrix &answer, double m, const FloatArray &lam, const FloatMatrix &N)
{   

  FloatArray  d(3), c(3);

  c.at(1) = pow(lam.at(1),  m);
  c.at(2) = pow(lam.at(2),  m);
  c.at(3) = pow(lam.at(3),  m);

  d.at(1)= m * pow(lam.at(1), m - 1.);
  d.at(2)= m * pow(lam.at(2), m - 1.);
  d.at(3)= m * pow(lam.at(3), m - 1.);
  
  FloatMatrix theta(3,3);
  
 
  // compute auxiliary variables 
  // the computation differes depends on if the eigenvalues of C are equal or not
  if(lam.at(1) != lam.at(2)) {
    if(lam.at(2) != lam.at(3)) {
      if(lam.at(1) != lam.at(3)) {
	// all eigenvalues are different
	for(int i = 1; i <= 3; i++) {
	  for(int j = 1; j <= 3; j++) {
	    if(i == j) {
	      continue;
	    } else {
	      theta.at(i,j) = (c.at(i) - c.at(j))/(lam.at(i) - lam.at(j));
	    }
	  }
	}
      } else { //l1 == l3 && l1 != l2
	for(int i = 1; i <= 3; i++) {
	  for(int j = 1; j <= 3; j++) {
	    if( i == j ) {
	      continue;
	    } else {
	      if((i == 1 && j == 3) || (i == 3 && j == 1) ) {
		theta.at(i,j) = 1./2.*d.at(i);
	      } else {
		theta.at(i,j) = (c.at(i) - c.at(j))/(lam.at(i) - lam.at(j));
	      }
	    }
	  }
	}	  
      }
    } else { //l2 == l3 && l1 != l2
      for(int i = 1; i <= 3; i++) {
	for(int j = 1; j <= 3; j++) {
	  if( i == j ) {
	    continue;
	  } else {
	    if((i == 2 && j == 3) || (i == 3 && j == 2) ) {
	      theta.at(i,j) = 1./2.*d.at(i);
	    } else {
	      theta.at(i,j) = (c.at(i) - c.at(j))/(lam.at(i) - lam.at(j));
	    }
	  }
	}
      } 
    }
  } else if(lam.at(1) != lam.at(3)) { // l1 == l2  && l1 != l3
    for(int i = 1; i <= 3; i++) {
      for(int j = 1; j <= 3; j++) {
	if( i == j ) {
	  continue;
	} else {
	  if((i == 1 && j == 2) || (i == 2 && j == 1) ) {
	    theta.at(i,j) = 1./2.*d.at(i);
	  } else {
	    theta.at(i,j) = (c.at(i) - c.at(j))/(lam.at(i) - lam.at(j));
	  }
	}
      }
    } 
  } else {  // l1 == l2 == l3
    for(int i = 1; i <= 3; i++) {
      for(int j = 1; j <= 3; j++) {
	theta.at(i,j) = 1./2. * d.at(i);
      }
    }
  }
  
  
  FloatMatrix M(9,9);
  
  for (int i = 1; i <= 3; i++) {
    for (int j = 1; j <= 3; j++) {
      for (int k = 1; k <= 3; k++) {
	for (int l = 1; l <=3; l++) {
	  M.at(giveVI(i,j),giveVI(k,l)) = N.at(k,i)*N.at(l,j) + N.at(k,j)*N.at(l,i);
	}
      }
    }
  }
    
  answer.resize(9,9);
  for (int k = 1; k <= 3; k++) {
    for (int l = 1; l <= 3; l++) {
      for (int m = 1; m <=3; m++) {
	for (int n = 1; n<=3; n++) {
	  for (int i = 1; i <= 3; i++) {
	    answer.at(giveVI(k,l),giveVI(m,n)) += 0.5 * d.at(i) * N.at(k,i) * N.at(l,i) * M.at(giveVI(i,i),giveVI(m,n));
	    for (int j  = 1; j <= 3; j++) {
	      if(j != i) {
		answer.at(giveVI(k,l),giveVI(m,n)) += 0.5 * theta.at(i,j)*N.at(k,i)*N.at(l,j)*M.at(giveVI(i,j),giveVI(m,n));
	      }
	    }
	  }
	}	    
      }
    }
  }
  answer.resizeWithData(6,6);
}



void
StructuralMaterial :: compute_dCm_dC(FloatMatrix &answer, double m, const FloatArray &lam, const FloatMatrix &N, const FloatArray &coeff)
{   

  FloatArray  d(3), c(3);

  c.at(1) = coeff.at(1) * pow(lam.at(1),  m);
  c.at(2) = coeff.at(2) * pow(lam.at(2),  m);
  c.at(3) = coeff.at(3) * pow(lam.at(3),  m);

  d.at(1)= coeff.at(1) * m * pow(lam.at(1), m - 1.);
  d.at(2)= coeff.at(2) * m * pow(lam.at(2), m - 1.);
  d.at(3)= coeff.at(3) * m * pow(lam.at(3), m - 1.);
  
  FloatMatrix theta(3,3);
  
 
  // compute auxiliary variables 
  // the computation differes depends on if the eigenvalues of C are equal or not
  if(lam.at(1) != lam.at(2)) {
    if(lam.at(2) != lam.at(3)) {
      if(lam.at(1) != lam.at(3)) {
	// all eigenvalues are different
	for(int i = 1; i <= 3; i++) {
	  for(int j = 1; j <= 3; j++) {
	    if(i == j) {
	      continue;
	    } else {
	      theta.at(i,j) = (c.at(i) - c.at(j))/(lam.at(i) - lam.at(j));
	    }
	  }
	}
      } else { //l1 == l3 && l1 != l2
	for(int i = 1; i <= 3; i++) {
	  for(int j = 1; j <= 3; j++) {
	    if( i == j ) {
	      continue;
	    } else {
	      if((i == 1 && j == 3) || (i == 3 && j == 1) ) {
		theta.at(i,j) = 1./2.*d.at(i);
	      } else {
		theta.at(i,j) = (c.at(i) - c.at(j))/(lam.at(i) - lam.at(j));
	      }
	    }
	  }
	}	  
      }
    } else { //l2 == l3 && l1 != l2
      for(int i = 1; i <= 3; i++) {
	for(int j = 1; j <= 3; j++) {
	  if( i == j ) {
	    continue;
	  } else {
	    if((i == 2 && j == 3) || (i == 3 && j == 2) ) {
	      theta.at(i,j) = 1./2.*d.at(i);
	    } else {
	      theta.at(i,j) = (c.at(i) - c.at(j))/(lam.at(i) - lam.at(j));
	    }
	  }
	}
      } 
    }
  } else if(lam.at(1) != lam.at(3)) { // l1 == l2  && l1 != l3
    for(int i = 1; i <= 3; i++) {
      for(int j = 1; j <= 3; j++) {
	if( i == j ) {
	  continue;
	} else {
	  if((i == 1 && j == 2) || (i == 2 && j == 1) ) {
	    theta.at(i,j) = 1./2.*d.at(i);
	  } else {
	    theta.at(i,j) = (c.at(i) - c.at(j))/(lam.at(i) - lam.at(j));
	  }
	}
      }
    } 
  } else {  // l1 == l2 == l3
    for(int i = 1; i <= 3; i++) {
      for(int j = 1; j <= 3; j++) {
	theta.at(i,j) = 1./2. * d.at(i);
      }
    }
  }
  
  
  FloatMatrix M(9,9);
  
  for (int i = 1; i <= 3; i++) {
    for (int j = 1; j <= 3; j++) {
      for (int k = 1; k <= 3; k++) {
	for (int l = 1; l <=3; l++) {
	  M.at(giveVI(i,j),giveVI(k,l)) = N.at(k,i)*N.at(l,j) + N.at(k,j)*N.at(l,i);
	}
      }
    }
  }
    
  answer.resize(9,9);
  for (int k = 1; k <= 3; k++) {
    for (int l = 1; l <= 3; l++) {
      for (int m = 1; m <=3; m++) {
	for (int n = 1; n<=3; n++) {
	  for (int i = 1; i <= 3; i++) {
	    answer.at(giveVI(k,l),giveVI(m,n)) += 0.5 * d.at(i) * N.at(k,i) * N.at(l,i) * M.at(giveVI(i,i),giveVI(m,n));
	    for (int j  = 1; j <= 3; j++) {
	      if(j != i) {
		answer.at(giveVI(k,l),giveVI(m,n)) += 0.5 * theta.at(i,j)*N.at(k,i)*N.at(l,j)*M.at(giveVI(i,j),giveVI(m,n));
	      }
	    }
	  }
	}	    
      }
    }
  }
  answer.resizeWithData(6,6);
}



void
StructuralMaterial :: computeMatrixPower(FloatMatrix &answer, const FloatArray &eVals, const FloatMatrix &eVecs, double m )
{

    answer.resize(3, 3);
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	answer.at(i, j) = pow(eVals.at(1),m) * eVecs.at(i, 1) * eVecs.at(j, 1) + pow(eVals.at(2),m) *eVecs.at(i, 2) * eVecs.at(j, 2) + pow(eVals.at(3),m) *eVecs.at(i, 3) * eVecs.at(j, 3);  
      }
    }
    
}


void
StructuralMaterial :: computeMatrixPower(FloatMatrix &answer, const FloatArray &eVals, const FloatMatrix &eVecs, double m, const FloatArray &coeff )
{

    answer.resize(3, 3);
    for ( int i = 1; i <= 3; i++ ) {
      for ( int j = 1; j <= 3; j++ ) {
	answer.at(i, j) = coeff.at(1) * pow(eVals.at(1),m) * eVecs.at(i, 1) * eVecs.at(j, 1) + coeff.at(2) * pow(eVals.at(2),m) *eVecs.at(i, 2) * eVecs.at(j, 2) + coeff.at(3) * pow(eVals.at(3),m) *eVecs.at(i, 3) * eVecs.at(j, 3);  
      }
    }
    
}



  
void
StructuralMaterial :: transformStrainVectorTo(FloatArray &answer, const FloatMatrix &base,
                                              const FloatArray &strainVector, bool transpose)
//
// performs transformation of 3d-strain vector to another system of axes,
// given by base.
// In base (FloatMatrix[3,3]) there are on each column stored vectors of
// coordinate system to which we do transformation. These vectors must
// be expressed in the same coordinate system as strainVector
//
// If transpose == 1 we transpose base matrix before transforming
{
    FloatMatrix tt;

    StructuralMaterial :: giveStrainVectorTranformationMtrx(tt, base, transpose);
    answer.beProductOf(tt, strainVector);
}


void
StructuralMaterial :: transformStressVectorTo(FloatArray &answer, const FloatMatrix &base,
                                              const FloatArray &stressVector, bool transpose)
//
//
// performs transformation of 3d-stress vector to another system of axes,
// given by base.
// In base (FloatMatrix[3,3]) there are on each column stored vectors of
// coordinate system to which we do transformation. These vectors must
// be expressed in the same coordinate system as strainVector
// If transpose == 1 we transpose base matrix before transforming
//

{
    FloatMatrix tt;

    StructuralMaterial :: giveStressVectorTranformationMtrx(tt, base, transpose);
    answer.beProductOf(tt, stressVector);
}


void
StructuralMaterial :: sortPrincDirAndValCloseTo(FloatArray *pVal, FloatMatrix *pDir,
                                                FloatMatrix *toPDir)
//
// this method sorts newly computed principal values (pVal) and
// corresponding principal directions (pDir) to be closed to
// some (often previous) principal directions (toPDir).
//
// remark : pDir and toPDir should have eigen vectors stored in columns
// and normalized.
//
{
    int maxJ = 0, size;
    double cosine, maxCosine, swap;

#ifdef DEBUG
    if ( ( !pDir->isSquare() ) || ( !toPDir->isSquare() ) ) {
        OOFEM_SERROR("Not square matrix");
    }

    if ( pDir->giveNumberOfRows() != toPDir->giveNumberOfRows() ) {
        OOFEM_SERROR("Incompatible matrices");
    }

    if ( pDir->giveNumberOfRows() != pVal->giveSize() ) {
        OOFEM_SERROR("Incompatible pVal Array size");
    }

#endif

    //
    // compute cosine matrix, where member i,j is cosine of angle
    // between toPDir i th eigen vector and j th pDir eigen vector
    //
    // sort pVal and pDir
    size = pDir->giveNumberOfRows();
    for ( int i = 1; i <= size - 1; i++ ) {
        // find closest pDir vector to toPDir i-th vector
        maxCosine = 0.0;
        for ( int j = i; j <= size; j++ ) {
            cosine = 0.;
            for ( int k = 1; k <= size; k++ ) {
                cosine += toPDir->at(k, i) * pDir->at(k, j);
            }

            cosine = fabs(cosine);
            if ( cosine > maxCosine ) {
                maxJ = j;
                maxCosine = cosine;
            }
        }

        // swap entries
        if ( maxJ != i ) {
            // swap eigenVectors and values
            swap = pVal->at(maxJ);
            pVal->at(maxJ) = pVal->at(i);
            pVal->at(i) = swap;
            for ( int k = 1; k <= size; k++ ) {
                swap = pDir->at(k, maxJ);
                pDir->at(k, maxJ) = pDir->at(k, i);
                pDir->at(k, i) = swap;
            }
        }
    }
}


int
StructuralMaterial :: setIPValue(const FloatArray &value, GaussPoint *gp, InternalStateType type)
{
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );
    if ( type == IST_StressTensor ) {
        status->letStressVectorBe(value);
        return 1;
    } else if ( type == IST_StrainTensor ) {
        status->letStrainVectorBe(value);
        return 1;
    } else if ( type == IST_StressTensorTemp ) {
        status->letTempStressVectorBe(value);
        return 1;
    } else if ( type == IST_StrainTensorTemp ) {
        status->letTempStrainVectorBe(value);
        return 1;
    } else {
        return 0;
    }
}


int
StructuralMaterial :: giveIPValue(FloatArray &answer, GaussPoint *gp, InternalStateType type, TimeStep *tStep)
{
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );
    if ( type == IST_StressTensor ) {
        StructuralMaterial :: giveFullSymVectorForm( answer, status->giveStressVector(), gp->giveMaterialMode() );
        return 1;
    } else if ( type == IST_StressTensor_Reduced ) {
        answer = status->giveStressVector();
        return 1;
    } else if ( type == IST_vonMisesStress ) {
        ///@todo What about the stress meassure in large deformations here? The internal state type should specify "Cauchy" or something.
        answer.resize(1);
        answer.at(1) = this->computeVonMisesStress( & status->giveStressVector() );
        return 1;
    } else if ( type == IST_StrainTensor ) {
        ///@todo Fill in correct full form values here! This just adds zeros!
        StructuralMaterial :: giveFullSymVectorForm( answer, status->giveStrainVector(), gp->giveMaterialMode() );
        /* commented out by Milan - this evaluation of the out-of-plane strain would be correct for elastic material only
         *                          and for other materials can lead to misleading values
         * if ( gp->giveMaterialMode() == _PlaneStress) {
         *  double Nxy = this->give(NYxy, gp);
         *  double Nxz = this->give(NYxz, gp);
         *  double Nyz = this->give(NYyz, gp);
         *  double Nyx = Nxy * this->give(Ey, gp) / this->give(Ex, gp);
         *  answer.at(3) = ( -( Nxz + Nxy * Nyz ) * answer.at(1) - ( Nyz + Nxz * Nyx ) * answer.at(2) ) / ( 1. - Nxy * Nyx );
         * }
         */
        return 1;
    } else if ( type == IST_StrainTensor_Reduced ) {
        ///@todo Fill in correct full form values here! This just adds zeros!
        answer = status->giveStrainVector();
        return 1;
    } else if ( type == IST_StressTensorTemp ) {
        ///@todo Fill in correct full form values here! This just adds zeros!
        StructuralMaterial :: giveFullSymVectorForm( answer, status->giveTempStressVector(), gp->giveMaterialMode() );
        return 1;
    } else if ( type == IST_StrainTensorTemp ) {
        ///@todo Fill in correct full form values here! This just adds zeros!
        StructuralMaterial :: giveFullSymVectorForm( answer, status->giveTempStrainVector(), gp->giveMaterialMode() );
        return 1;
    } else if ( type == IST_PrincipalStressTensor || type == IST_PrincipalStressTempTensor ) {
        FloatArray s;

        if ( type == IST_PrincipalStressTensor ) {
            ///@todo Fill in correct full form values here! This just adds zeros!
            StructuralMaterial :: giveFullSymVectorForm( s, status->giveStressVector(), gp->giveMaterialMode() );
        } else {
            ///@todo Fill in correct full form values here! This just adds zeros!
            StructuralMaterial :: giveFullSymVectorForm( s, status->giveTempStressVector(), gp->giveMaterialMode() );
        }

        this->computePrincipalValues(answer, s, principal_stress);
        return 1;
    } else if ( type == IST_PrincipalStrainTensor || type == IST_PrincipalStrainTempTensor ) {
        FloatArray s;

        if ( type == IST_PrincipalStrainTensor ) {
            ///@todo Fill in correct full form values here! This just adds zeros!
            StructuralMaterial :: giveFullSymVectorForm( s, status->giveStrainVector(), gp->giveMaterialMode() );
        } else {
            ///@todo Fill in correct full form values here! This just adds zeros!
            StructuralMaterial :: giveFullSymVectorForm( s, status->giveTempStrainVector(), gp->giveMaterialMode() );
        }

        this->computePrincipalValues(answer, s, principal_strain);
        return 1;
    } else if ( type == IST_Temperature ) {
        /* add external source, if provided, such as staggered analysis */
        FieldManager *fm = domain->giveEngngModel()->giveContext()->giveFieldManager();
        FieldPtr tf;
        int err;
        if ( ( tf = fm->giveField(FT_Temperature) ) ) {
            // temperature field registered
            FloatArray gcoords, et2;
            static_cast< StructuralElement * >( gp->giveElement() )->computeGlobalCoordinates( gcoords, gp->giveNaturalCoordinates() );
            if ( ( err = tf->evaluateAt(answer, gcoords, VM_Total, tStep) ) ) {
                OOFEM_ERROR("tf->evaluateAt failed, element %d, error code %d", gp->giveElement()->giveNumber(), err);
            }
        } else {
            answer.resize(1);
            answer.zero();
        }

        return 1;
    } else if ( type == IST_CylindricalStressTensor || type == IST_CylindricalStrainTensor ) {
        FloatArray gc, val = status->giveStressVector();
        FloatMatrix base(3, 3);
        static_cast< StructuralElement * >( gp->giveElement() )->computeGlobalCoordinates( gc, gp->giveNaturalCoordinates() );
        double l = sqrt( gc.at(1) * gc.at(1) + gc.at(2) * gc.at(2) );
        if ( l > 1.e-4 ) {
            base.at(1, 1) = gc.at(1) / l;
            base.at(2, 1) = gc.at(2) / l;
            base.at(3, 1) = 0.0;

            base.at(1, 2) = -1.0 * base.at(2, 1);
            base.at(2, 2) = base.at(1, 1);
            base.at(3, 2) = 0.0;

            base.at(1, 3) = 0.0;
            base.at(2, 3) = 0.0;
            base.at(3, 3) = 1.0;

            if ( type == IST_CylindricalStressTensor ) {
                this->transformStressVectorTo(answer, base, val, false);
            } else {
                this->transformStrainVectorTo(answer, base, val, false);
            }
        } else {
            answer = val;
        }

        return 1;
    } else if (type == IST_PlasticStrainTensor ) {
        StructuralMaterial :: giveFullSymVectorForm( answer, status->giveStrainVector(), gp->giveMaterialMode() );
        answer.zero();
        return 1;
    } else if (type == IST_MaxEquivalentStrainLevel ) {
        answer.resize(1);
        answer.at(1)=0.;
        return 1;
    } else if ( type == IST_DeformationGradientTensor ) {
        answer = status->giveFVector();
        return 1;
    } else if ( type == IST_FirstPKStressTensor ) {
        answer = status->givePVector();
        return 1;
    } else if ( type == IST_EigenStrainTensor ) {
        FloatArray eigenstrain;
        StructuralElement *selem = dynamic_cast< StructuralElement * >( gp->giveElement() );
        selem->computeResultingIPEigenstrainAt(eigenstrain, tStep, gp, VM_Total );
        StructuralMaterial :: giveFullSymVectorForm( answer, eigenstrain, gp->giveMaterialMode() );
        return 1;
    } else if ( type == IST_ShellForceTensor ) {
        answer.resize(6);
        answer.zero();
        return 1;
    } else {
        return Material :: giveIPValue(answer, gp, type, tStep);
    }
}

void
StructuralMaterial :: computeStressIndependentStrainVector(FloatArray &answer,
                                                           GaussPoint *gp, TimeStep *tStep, ValueModeType mode)
{
    FloatArray et, eigenstrain;
    if ( gp->giveIntegrationRule() == NULL ) {
        ///@todo Hack for loose gausspoints. We shouldn't ask for "gp->giveElement()". FIXME
        answer.clear();
        return;
    }
    Element *elem = gp->giveElement();
    StructuralElement *selem = dynamic_cast< StructuralElement * >( gp->giveElement() );

    answer.clear();

    if ( tStep->giveIntrinsicTime() < this->castingTime ) {
        answer.zero();
        return;
    }

    //sum up all prescribed temperatures over an element
    //elem->computeResultingIPTemperatureAt(et, tStep, gp, mode);
    if ( selem ) {
        selem->computeResultingIPTemperatureAt(et, tStep, gp, mode);
    }

    //sum up all prescribed eigenstrain over an element
    if ( selem ) {
        selem->computeResultingIPEigenstrainAt(eigenstrain, tStep, gp, mode);
    }

    if ( eigenstrain.giveSize() != 0 && eigenstrain.giveSize() != giveSizeOfVoigtSymVector(gp->giveMaterialMode()) ) {
        OOFEM_ERROR( "Number of given eigenstrain components %d is different than required %d by element %d", eigenstrain.giveSize(), giveSizeOfVoigtSymVector(gp->giveMaterialMode()), elem->giveNumber() );
    }

    /* add external source, if provided */
    FieldManager *fm = domain->giveEngngModel()->giveContext()->giveFieldManager();
    FieldPtr tf;

    if ( ( tf = fm->giveField(FT_Temperature) ) ) {
        // temperature field registered
        FloatArray gcoords, et2;
        int err;
        elem->computeGlobalCoordinates( gcoords, gp->giveNaturalCoordinates() );
        if ( ( err = tf->evaluateAt(et2, gcoords, mode, tStep) ) ) {
            OOFEM_ERROR("tf->evaluateAt failed, element %d, error code %d", elem->giveNumber(), err);
        }

        if ( et2.isNotEmpty() ) {
            if ( et.isEmpty() ) {
                et = et2;
            } else {
                et.at(1) += et2.at(1);
            }
        }
    }


    if ( et.giveSize() ) { //found temperature boundary conditions or prescribed field
        FloatArray fullAnswer, e0;

        this->giveThermalDilatationVector(e0, gp, tStep);

        if ( e0.giveSize() ) {
            fullAnswer = e0;
            if ( mode == VM_Total ) {
                fullAnswer.times(et.at(1) - this->referenceTemperature);
            } else {
                fullAnswer.times( et.at(1) );
            }

            StructuralMaterial :: giveReducedSymVectorForm( answer, fullAnswer, gp->giveMaterialMode() );
            //answer = fullAnswer;
        }
    }

    //join temperature and eigenstrain vectors, compare vector sizes
    if ( answer.giveSize() ) {
        if ( eigenstrain.giveSize() ) {
            if ( answer.giveSize() != eigenstrain.giveSize() ) {
                OOFEM_ERROR( "Vector of temperature strains has the size %d which is different with the size of eigenstrain vector %d, element %d", answer.giveSize(), eigenstrain.giveSize(), elem->giveNumber() );
            }

            answer.add(eigenstrain);
        }
    } else {
        if ( eigenstrain.giveSize() ) {
            answer = eigenstrain;
        }
    }
}


void
StructuralMaterial :: giveFullSymVectorForm(FloatArray &answer, const FloatArray &vec, MaterialMode matMode)
{
    if ( vec.giveSize() == 6 ) {
        // If we use default 3D implementation to treat e.g. plane strain.
        answer = vec;
    } else {
        IntArray indx;
        answer.resize( StructuralMaterial :: giveVoigtSymVectorMask(indx, matMode) );
        answer.zero();
        answer.assemble(vec, indx);
    }
}


void
StructuralMaterial :: giveFullVectorForm(FloatArray &answer, const FloatArray &vec, MaterialMode matMode)
{
  if(vec.giveSize() == 9) {
    answer = vec;
  } else {
    IntArray indx;
    answer.resize( StructuralMaterial :: giveVoigtVectorMask(indx, matMode) );
    answer.zero();
    answer.assemble(vec, indx);
  }
}


void
StructuralMaterial :: giveFullVectorFormF(FloatArray &answer, const FloatArray &vec, MaterialMode matMode)
{
    IntArray indx;
    answer.resize(9);
    answer.at(1) = answer.at(2) = answer.at(3) = 1.0;   // set diagonal terms

    StructuralMaterial :: giveVoigtVectorMask(indx, matMode);
    for ( int i = 1; i <= indx.giveSize(); i++ ) {
        answer.at( indx.at(i) ) = vec.at(i);
    }
}


void
StructuralMaterial :: giveReducedVectorForm(FloatArray &answer, const FloatArray &vec, MaterialMode matMode)
{
    IntArray indx;
    StructuralMaterial :: giveVoigtVectorMask(indx, matMode);
    answer.resize( indx.giveSize() );
    for ( int i = 1; i <= indx.giveSize(); i++ ) {
        answer.at(i) = vec.at( indx.at(i) );
    }
}


void
StructuralMaterial :: giveReducedSymVectorForm(FloatArray &answer, const FloatArray &vec, MaterialMode matMode)
{
    IntArray indx;
    StructuralMaterial :: giveVoigtSymVectorMask(indx, matMode);

    if ( indx.giveSize() == vec.giveSize() ) {
        answer = vec;
    } else {
        answer.resize( indx.giveSize() );
        for ( int i = 1; i <= indx.giveSize(); i++ ) {
            answer.at(i) = vec.at( indx.at(i) );
        }
    }
}


void
StructuralMaterial :: giveFullSymMatrixForm(FloatMatrix &answer, const FloatMatrix &red, MaterialMode matMode)
{
    IntArray indx;
    int size = StructuralMaterial :: giveVoigtSymVectorMask(indx, matMode);
    answer.resize(size, size);
    answer.zero();
    answer.assemble(red, indx, indx);
}


void
StructuralMaterial :: giveReducedMatrixForm(FloatMatrix &answer, const FloatMatrix &full, MaterialMode matMode)
{
    IntArray indx;
    StructuralMaterial :: giveVoigtVectorMask(indx, matMode);
    answer.beSubMatrixOf(full, indx, indx);
}


void
StructuralMaterial :: giveReducedSymMatrixForm(FloatMatrix &answer, const FloatMatrix &full, MaterialMode matMode)
{
    IntArray indx;
    StructuralMaterial :: giveVoigtSymVectorMask(indx, matMode);
    answer.beSubMatrixOf(full, indx, indx);
}



IRResultType
StructuralMaterial :: initializeFrom(InputRecord *ir)
{
    IRResultType result;                // Required by IR_GIVE_FIELD macro

    referenceTemperature = 0.0;
    IR_GIVE_OPTIONAL_FIELD(ir, referenceTemperature, _IFT_StructuralMaterial_referencetemperature);

    return Material :: initializeFrom(ir);
}


void
StructuralMaterial :: giveInputRecord(DynamicInputRecord &input)
{
    Material :: giveInputRecord(input);
    input.setField(this->referenceTemperature, _IFT_StructuralMaterial_referencetemperature);
}
} // end namespace oofem
